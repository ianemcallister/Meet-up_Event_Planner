"use strict";

var meetUpEventApp = angular.module('meetUpEventApp', ['ngRoute', 'ngTouch', 'firebase']);
"use strict";

meetUpEventApp.controller('AnEventController', AnEventController);
AnEventController.$inject = ['$log', '$routeParams'];
/* @ngInject */

function AnEventController($log, $routeParams) {
  var vm = this; //local variables

  vm.tempTime = {
    start: '',
    end: ''
  };
  vm.userIsHost = false; //Local Methods

  function init() {
    //declare and initialize local variables
    vm.tempDateTime = {
      start: '',
      end: ''
    };
    vm.newGuest = {
      name: '',
      email: {
        address: '',
        valid: false,
        style: {
          color: ''
        }
      }
    };
    vm.showIfHost = false;
    vm.hideIfAttending = true; //sections

    vm.manageSections = {
      1: {
        active: true,
        complete: false,
        style: {
          color: 'black',
          'background-color': 'yellow'
        }
      },
      2: {
        active: false,
        complete: false,
        style: {
          color: 'white',
          'background-color': 'gray'
        }
      },
      3: {
        active: false,
        complete: false,
        style: {
          color: 'white',
          'background-color': 'gray'
        }
      }
    }; //check user to determine state

    checkForHost();
    checkIfGuestIsAttending(); //open up sections

    if (!vm.showIfHost) openAllSections();
  }

  function utf8_to_b64(str) {
    return btoa(str);
  }

  function b64_to_utf8(str) {
    return atob(str);
  }

  function dateTimeToUnixTime(dateTime) {
    return Date.parse(dateTime);
  }

  function cleanNewGuestVariable() {
    vm.newGuest = {
      name: '',
      email: {
        address: '',
        valid: false,
        style: {
          color: ''
        }
      }
    };
  }

  function inviteARegisteredUser(uid) {
    //$log.info('adding them to the registered users list ' + uid);
    //set the new event
    ref.child('Users').child(uid).child('events').child('pending').child($routeParams.uid).child($routeParams.eventId).set({
      id: $routeParams.eventId,
      eventTimes: {
        start: vm.event.eventTimes.start,
        end: vm.event.eventTimes.end
      },
      name: vm.event.name,
      host: $routeParams.uid
    }, function (error) {
      if (error) $log.info('there was an error' + error);
    }); //if there was an updated place holder, remove it

    ref.child('Users').child(uid).child('events').child('pending').once('value', function (snapshot) {
      var checkForPlaceholder = snapshot.val();
      $log.info(snapshot.val());

      if (checkForPlaceholder.updated) {
        $log.info('deleting updated');
        ref.child('Users').child(uid).child('events').child('pending').child('updated').remove(function (errorObject) {
          if (errorObject) $log.info("Deleting failed: " + errorObject.code);
        });
      } else $log.info('nothing to do');
    }, function (errorObject) {
      if (errorObject) $log.info("The read failed: " + errorObject.code);
    });
  }

  function inviteAnUnregisteredUser(userKey) {
    $log.info('adding them to the UNREGISTERED users list ' + userKey);
    ref.child('UnregisteredUsers').child(userKey).child('pending').child($routeParams.uid).child($routeParams.eventId).set({
      id: $routeParams.eventId,
      host: $routeParams.uid,
      eventTimes: {
        start: vm.event.eventTimes.start,
        end: vm.event.eventTimes.end
      },
      name: vm.event.name
    }, function (error) {
      if (error) $log.info('there was an error' + error);
    });
  }

  function checkForHost() {
    //check event host
    var authData = ref.getAuth();

    if (authData.uid == $routeParams.hostId) {
      $log.info('is the host');
      vm.showIfHost = true;
    } else {
      $log.info('not the host');
      vm.showIfHost = false;
    }
  }

  function checkIfGuestIsAttending() {
    if (!vm.showIfHost) {
      $log.info('check guest attendance');
      userEvents.child('guestList').on('value', function (snapshot) {
        var allGuests = snapshot.val();
        vm.hideIfAttending = !allGuests[$routeParams.uid].attending;
      });
    }
  }

  function openAllSections() {
    vm.manageSections[1].active = true;
    vm.manageSections[2].active = true;
    vm.manageSections[3].active = true;
  }

  function saveEvent() {
    vm.event.$save().then(function () {
      $log.info('event saved');
    })["catch"](function (error) {
      $log.info('error! ' + error);
    });
  } //view Method


  vm.setTempTime = function (endpoint) {
    if (endpoint == 'start') vm.tempDateTime.start = new Date();
    if (endpoint == 'end') vm.tempDateTime.end = new Date();
  };

  vm.unixTimeToDateTime = function (unixTime) {
    return new Date(parseInt(unixTime));
  };

  vm.dateTimeToUnixTime = function (dateTime) {
    return Date.parse(dateTime);
  };

  vm.submit = function () {
    $log.info('submitting the form now!');
  };

  vm.backToUserEvents = function () {
    $location.path('/userEvents/' + $routeParams.uid + '/' + $routeParams.token);
  };

  vm.eventRedirect = function (path, eventID) {
    var fullPath = path + '/' + $routeParams.uid + '/' + $routeParams.token; //redirect

    $log.info('redirecting to: ' + fullPath);
    $location.path(fullPath);
  };

  vm.changeSection = function (targetSection) {
    $log.info('are we here');

    for (i = 1; i <= 3; i++) {
      if (i == targetSection) {
        vm.manageSections[i].active = true;
        vm.manageSections[i].style['background-color'] = 'yellow';
        vm.manageSections[i].style['color'] = 'black';
      } else {
        vm.manageSections[i].active = false;
        vm.manageSections[i].style['background-color'] = 'gray';
        vm.manageSections[i].style['color'] = 'white';
      }
    }
  };

  vm.saveEventTime = function (dateTime, target) {
    //if this event didn't have a start time, create it
    if (!vm.event.eventTimes) {
      vm.event.eventTimes = {
        start: '',
        end: ''
      };
      vm.event.eventTimes.start = vm.dateTimeToUnixTime(vm.tempDateTime.start);
      vm.event.eventTimes.end = vm.dateTimeToUnixTime(vm.tempDateTime.end);
    }

    if (vm.tempDateTime.end < vm.tempDateTime.start && target == 'start') vm.tempDateTime.end = vm.tempDateTime.start;
    if (target == 'start') vm.event.eventTimes.start = vm.dateTimeToUnixTime(dateTime);
    if (target == 'end') vm.event.eventTimes.end = vm.dateTimeToUnixTime(dateTime);
  };

  vm.guestsAreInvited = function () {
    if (vm.event.guestList) return true;else return false;
  };

  vm.validateGuestEmail = function () {
    //if there is an email address
    if (vm.newGuest.email.address) {
      //check validity
      var constraint = new RegExp("[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?", "");

      if (constraint.test(vm.newGuest.email.address)) {
        vm.newGuest.email.valid = true;
        vm.newGuest.email.style = {
          color: 'green'
        };
      } else {
        vm.newGuest.email.valid = false;
        vm.newGuest.email.style = {
          color: ''
        };
      }
    }
  };

  vm.isSectionComplete = function () {
    for (i = 0; i < 8; i++) {
      $log.info(vm.requiredInputs[i]);
    }
  };

  vm.saveAndAdvance = function () {
    vm.event.$save().then(function () {
      $log.info('event saved');
    })["catch"](function (error) {
      $log.info('error! ' + error);
    }); //check for completenes

    vm.isSectionComplete();

    if (vm.manageSections[1].complete == true && vm.manageSections[2].complete == true && vm.manageSections[3].complete == true) {
      vm.eventRedirect('/userEvents', $routeParams.uid);
    } else if (vm.manageSections[1].active) vm.changeSection(2);else if (vm.manageSections[2].active) vm.changeSection(3);else if (vm.manageSections[3].active) vm.changeSection(1);
  };

  vm.addGuestToHostsList = function () {
    //declare and initialize local variables
    var userKey = utf8_to_b64(vm.newGuest.email.address); //if email is valid and name exists

    if (vm.newGuest.name && vm.newGuest.email.valid) {
      //is there a guest list already? If not create one
      if (!vm.event.guestList) {
        vm.event.guestList = {};
      } else {
        //if so is this person already on the list?
        var i = 0;

        while (vm.event.guestList[i]) {
          if (vm.event.guestList[i].email == b64_to_utf8(userKey)) {
            $log.info('This guest is already on the list');
            cleanNewGuestVariable();
            return;
          }

          i++;
        }
      } //is this guest a registered user?


      if (registeredUsers[userKey]) {
        //is the registered user the host?
        if (registeredUsers[userKey] == $routeParams.uid) {
          $log.info('tried to register the host');
          cleanNewGuestVariable();
          return;
        } else {
          //add them to the appropriate registered users' list of event invites
          inviteARegisteredUser(registeredUsers[userKey]); //add the guest to the list

          vm.event.guestList[registeredUsers[userKey]] = {
            attending: false,
            status: 'pending',
            name: vm.newGuest.name,
            email: vm.newGuest.email.address
          };
        }
      } else {
        //add the invite to the non-registered users list of event invites
        inviteAnUnregisteredUser(userKey); //add the guest to the list

        vm.event.guestList[userKey] = {
          attending: false,
          status: 'pending',
          name: vm.newGuest.name,
          email: vm.newGuest.email.address
        };
      } //save the event


      vm.saveEvent(); //clear the temp values

      cleanNewGuestVariable();
    } else {
      $log.info('you didn\'t enter a name and or email');
    }
  };

  vm.guestWillAttend = function (response) {
    var currentUser = ref.child('Users').child($routeParams.uid).child('events');
    var totalPendingInvitations = 0;
    var removeAttendingUpdated = false; //change attending to true in host's guestList

    vm.event.guestList[$routeParams.uid].attending = response; //change status to 'attending' in host's guestList

    vm.event.guestList[$routeParams.uid].status = 'attending'; //get the invitation details

    currentUser.child('pending').on('value', function (snapshot) {
      //define local varialbe
      var invitations = snapshot.val(); //log starting values

      $log.info(invitations);
      $log.info(invitations[$routeParams.hostId]);
      $log.info(invitations[$routeParams.hostId][$routeParams.eventId]);
      var thisInvitation = invitations[$routeParams.hostId][$routeParams.eventId];
      $log.info(thisInvitation); //check # of iniviations

      for (invitation in invitations) {
        totalPendingInvitations++;
      } //report # of invitations


      $log.info("total attending: " + totalPendingInvitations); //add the event to the guest's attending list

      if (response) currentUser.child('attending').child($routeParams.hostId).child($routeParams.eventId).set(thisInvitation, function (error) {
        if (error) $log.info(error);
      });
    }); //if the updated placeholder was on the attending list remove it

    currentUser.child('attending').on('value', function (snapshot) {
      //local variables
      var attendingList = snapshot.val(); //report actions

      $log.info('this is the attending list');
      $log.info(attendingList); //throw flag for later

      if (attendingList.updated) removeAttendingUpdated = true;
    }, function (error) {
      //if ther was an error report it
      if (error) $log.info(error);
    }); //if this is the last pending event on the guest's pending list, add the updated placeholder

    if (totalPendingInvitations < 2) {
      //local variables
      var currentDate = new Date(); //replace with updated field

      currentUser.child('pending').update({
        updated: dateTimeToUnixTime(currentDate)
      }, function (error) {
        if (error) $log.info(error);
      });
    } //remove the event from the guest's pending list


    currentUser.child('pending').child($routeParams.hostId).remove(); //if there was an updated field in attending, remove it

    if (removeAttendingUpdated) {
      $log.info('removing the updated placeholder'); //currentUser.child('attending').child('updated').remove();
    } //save changes


    vm.event.$save();
  };

  vm.updateUpdatedParam = function () {
    var currentUser = ref.child('Users').child($routeParams.uid).child('events');
    $log.info('updating the param');
    currentUser.child('attending').on('value', function (snapshot) {
      $log.info(snapshot.val());
    });
    currentUser.child('attending').child('updated').remove();
  };

  vm.addInvitationToAttending = function (response) {
    var currentUser = ref.child('Users').child($routeParams.uid).child('events');
    var totalPendingInvitations = 0; //get the invitation details

    currentUser.child('pending').on('value', function (snapshot) {
      //define local varialbe
      var invitations = snapshot.val();
      var thisInvitation = invitations[$routeParams.hostId][$routeParams.eventId]; //log starting values

      $log.info(invitations);
      $log.info(invitations[$routeParams.hostId]);
      $log.info(invitations[$routeParams.hostId][$routeParams.eventId]); //check # of iniviations

      for (invitation in invitations) {
        totalPendingInvitations++;
      } //report # of invitations


      $log.info("total pending invitations: " + totalPendingInvitations);
      $log.info(response); //add the event to the guest's attending list

      if (response) currentUser.child('attending').child($routeParams.hostId).child($routeParams.eventId).set(thisInvitation, function (error) {
        if (error) $log.info(error);
      });
    });
  }; //start run


  init();
}
"use strict";

meetUpEventApp.controller('GuestEventController', GuestEventController);
GuestEventController.$inject = ['$log'];
/* @ngInject */

function GuestEventController($log) {
  $log.info('into the GuestEventController');
}
"use strict";

meetUpEventApp.controller('HostEventController', HostEventController);
HostEventController.$inject = ['$scope', '$log', '$routeParams', '$document', 'userData', 'trafficValet', 'validation'];
/* @ngInject */

function HostEventController($scope, $log, $routeParams, $document, userData, trafficValet, validation) {
  var vm = this; //local variables

  var hostedEventSherpa = trafficValet;
  var thisEventManager = userData;
  var requirnmentsFactory = validation; //local variables

  var percentComplete = 0; //view model variables

  vm.activeSection = 1;
  vm.tempTime = {
    start: '',
    end: '',
    duration: ''
  };
  vm.progressBar = {
    complete: vm.percentComplete,
    style: {
      width: vm.percentComplete + '%'
    },
    message: vm.percentComplete + '%'
  };
  vm.actionBtn = {
    div: {
      "class": {
        'col-xs-6': true,
        'col-sm-6': true
      }
    },
    btn: {
      "class": {
        'btn': true,
        'btn-success': false,
        'btn-warning': true,
        'pull-right': true
      },
      message: 'Add Info'
    }
  };
  vm.tempEvent = {};
  vm.requiredFieldComplete = requirnmentsFactory.generateEventRequirnments(); //local methods

  function unixTimeToDateTime(unixTime) {
    return new Date(parseInt(unixTime));
  }

  ;

  function dateTimeToUnixTime(dateTime) {
    return Date.parse(dateTime);
  }

  ;

  function calculateDuration(start, end) {
    return (dateTimeToUnixTime(end) - dateTimeToUnixTime(start)) / (60 * 1000);
  }

  function changeSaveBtn(direction) {
    if (direction == 'open') {
      vm.actionBtn.btn["class"]['btn-success'] = true;
      vm.actionBtn.btn["class"]['btn-warning'] = false;
      vm.actionBtn.btn.message = 'Save Event';
    } else if (direction == 'close') {
      vm.actionBtn.btn["class"]['btn-success'] = false;
      vm.actionBtn.btn["class"]['btn-warning'] = true;
      vm.actionBtn.btn.message = 'Add Info';
    }
  }

  function updateProgressBar(units) {
    percentComplete += units;
    vm.progressBar.complete = percentComplete;
    vm.progressBar.style.width = percentComplete + '%';
    vm.progressBar.message = percentComplete + '%';
    if (percentComplete > 99) changeSaveBtn('open');
    if (percentComplete < 99) changeSaveBtn('close');
  }

  function initEventTimes() {
    //build new temp times
    var now = new Date(); //round to the nearest hour, cut off anything smaller

    now.setHours(now.getHours() + Math.round(now.getMinutes() / 60));
    now.setMinutes(0);
    now.setSeconds(0);
    now.setMilliseconds(0);
    vm.tempTime.start = now;
    vm.tempTime.end = now;
    vm.tempTime.duration = calculateDuration(vm.tempTime.start, vm.tempTime.end);
  }

  function updateTempTimeFromModel() {
    //if start times are available
    if (angular.isDefined(vm.tempEvent.eventTimes.start)) {
      //set the tempTime model
      vm.tempTime.start = unixTimeToDateTime(vm.tempEvent.eventTimes.start);
      vm.tempTime.end = unixTimeToDateTime(vm.tempEvent.eventTimes.end);
    }
  }

  function loadExistingValues() {
    //loop through each event object, if it exists credit the progress bar
    Object.keys(vm.tempEvent).forEach(function (key) {//$log.info(vm.tempEvent[key]);
      //
    });
  }

  function init() {
    //if there is an active event, load it
    if (thisEventManager.thereIsAnActiveEvent()) {
      var activePackage = thisEventManager.getActiveEvent();
      vm.progressBar = activePackage.progressBar;
      percentComplete = activePackage.percentComplete;
      vm.tempEvent = activePackage.event;
      vm.requiredFieldComplete = activePackage.requiredFields;
    } else {
      //load event details
      thisEventManager.loadAnEventProgressively($routeParams.uid, $routeParams.eventId).then(function (theEvent) {
        //add this event model to the view model event
        vm.tempEvent = theEvent; //update tempTime

        updateTempTimeFromModel();
      })["catch"](function (error) {
        $log('the error is: ' + error);
      });
    } //load specified section


    vm.activeSection = parseInt($routeParams.section); //set tempTimes

    initEventTimes(); //set the progress bar for existing values

    loadExistingValues();
  } //view model methods


  vm.formatDuration = function () {
    //calc duration
    vm.tempTime.duration = calculateDuration(vm.tempTime.start, vm.tempTime.end); //local variables

    var hours = Math.floor(vm.tempTime.duration / 60);
    var min = vm.tempTime.duration % 60;
    var fraction = Math.round(min / 15) / 4;
    return hours + fraction + ' h';
  };

  vm.validateTime = function (startOrEnd) {
    if (vm.tempTime.duration > 24) vm.settingTempStart(); //local variables

    var times = {
      'eventStart': vm.tempTime.start,
      'eventEnd': vm.tempTime.end
    };

    if (angular.isDefined(times[startOrEnd]) && times[startOrEnd] != '' && vm.tempTime.duration > 0) {
      if (vm.requiredFieldComplete[startOrEnd].completed == false) updateProgressBar(10);
      vm.tempEvent.eventTimes.start = dateTimeToUnixTime(vm.tempTime.start);
      vm.tempEvent.eventTimes.end = dateTimeToUnixTime(vm.tempTime.end);
      vm.requiredFieldComplete[startOrEnd].completed = true;
      vm.requiredFieldComplete[startOrEnd].row["class"]['has-success'] = true;
      vm.requiredFieldComplete[startOrEnd].row["class"]['has-feedback'] = true;
      vm.requiredFieldComplete[startOrEnd].row["class"]['has-error'] = false;
    } else {
      if (vm.requiredFieldComplete[startOrEnd].completed == true) updateProgressBar(-10);
      vm.requiredFieldComplete[startOrEnd].completed = false;
      vm.requiredFieldComplete[startOrEnd].row["class"]['has-success'] = false;
      vm.requiredFieldComplete[startOrEnd].row["class"]['has-feedback'] = false;
      vm.requiredFieldComplete[startOrEnd].row["class"]['has-error'] = true;
    }
  };

  vm.settingTempStart = function () {
    if (dateTimeToUnixTime(vm.tempTime.end) <= dateTimeToUnixTime(vm.tempTime.start) || dateTimeToUnixTime(vm.tempTime.end) - dateTimeToUnixTime(vm.tempTime.start) > 1000 * 60 * 60 * 24) {
      oldStart = dateTimeToUnixTime(vm.tempTime.start);
      oldEnd = dateTimeToUnixTime(vm.tempTime.end);
      newEnd = oldStart + 60 * 60 * 1000;
      vm.tempTime.end = unixTimeToDateTime(newEnd);
    }
  };

  vm.settingTempEnd = function () {
    //set valid end with start
    if (vm.tempTime.start > vm.tempTime.end) vm.tempTime.start = vm.tempTime.end; //validate

    vm.validateTime('eventEnd'); //calc duration

    vm.tempTime.duration = calculateDuration(vm.tempTime.start, vm.tempTime.end);
  };

  vm.backToUserEvents = function () {
    //if the event is completed, save to the db
    //check that the event is complete
    if (percentComplete > 99) {
      //if so save the event locally
      thisEventManager.saveNewHostingEvent('hosting', vm.tempEvent); //then sync the local with the db

      thisEventManager.setRemoteEventsFromLocal('hosting', vm.tempEvent).then(function (succesMessage) {
        $log.info(succesMessage);
      })["catch"](function (erroMessage) {
        $log.info(erroMessage);
      });
    } //if not completed, delete the event entirely
    //thisEventManager.removeIncompleteEventFromDB(vm.tempEvent.id);
    //send the user back to the page they came from


    hostedEventSherpa.redirectTo('/userEvents', $routeParams.uid);
  };

  vm.sectionBack = function () {
    //save temp event package
    var eventPackage = {
      event: vm.tempEvent,
      progressBar: vm.progressBar,
      percentComplete: percentComplete,
      requiredFields: vm.requiredFieldComplete
    }; //$log.info(eventPackage);

    thisEventManager.setActiveEvent(eventPackage); //move back

    targetSection = vm.activeSection - 1;
    hostedEventSherpa.redirectTo('/event/host', $routeParams.eventId, $routeParams.uid, targetSection);
  };

  vm.sectionForward = function () {
    //if all required fields have been entered
    //save temp event package
    var eventPackage = {
      event: vm.tempEvent,
      progressBar: vm.progressBar,
      percentComplete: percentComplete,
      requiredFields: vm.requiredFieldComplete
    }; //$log.info(eventPackage);

    thisEventManager.setActiveEvent(eventPackage); //move forward

    targetSection = vm.activeSection + 1;
    hostedEventSherpa.redirectTo('/event/host', $routeParams.eventId, $routeParams.uid, targetSection);
  };

  vm.verifyRequired = function (field, value) {
    //check validity
    if (angular.isDefined(value) && value != '') {
      if (vm.requiredFieldComplete[field].completed == false) {
        updateProgressBar(10);
      }

      vm.requiredFieldComplete[field].completed = true;
      vm.requiredFieldComplete[field].row["class"]['has-success'] = true;
      vm.requiredFieldComplete[field].row["class"]['has-feedback'] = true;
      vm.requiredFieldComplete[field].row["class"]['has-error'] = false;
    } else {
      if (vm.requiredFieldComplete[field].completed == true) {
        updateProgressBar(-10);
      }

      vm.requiredFieldComplete[field].completed = false;
      vm.requiredFieldComplete[field].row["class"]['has-success'] = false;
      vm.requiredFieldComplete[field].row["class"]['has-feedback'] = false;
      vm.requiredFieldComplete[field].row["class"]['has-error'] = true;
    } //field updated

  };

  vm.saveEventToDB = function () {
    //$log.info(vm.tempEvent);
    //check that the event is complete
    if (percentComplete > 99) {
      //if so save the event locally
      thisEventManager.saveNewHostingEvent('hosting', vm.tempEvent); //then sync the local with the db

      thisEventManager.setRemoteEventsFromLocal($routeParams.uid, vm.tempEvent).then(function (succesMessage) {
        $log.info(succesMessage); //in succes make sure to remove the updated field

        thisEventManager.cleanDBEventsCategory('hosting').then(function (succesMessage) {
          $log.info(succesMessage);
        })["catch"](function (erroMessage) {
          $log.info(erroMessage);
        });
      })["catch"](function (erroMessage) {
        $log.info(erroMessage);
      }); //redirect back to events

      hostedEventSherpa.redirectTo('/userEvents', $routeParams.uid);
    }
  }; //watchers


  $scope.$watch('vm.tempEvent.guestList', function (current, original) {
    //if a guest is added to the list update the progress bar
    if (angular.isObject(vm.tempEvent.guestList)) {
      updateProgressBar(10);
    }
  });
  angular.element($document).ready(function () {
    if (parseInt($routeParams.section) == 1) {//angular.element($document.querySelector('#eventName')).focus()
      //angular.element($document).find('#eventName').focus();
      //$log.info('section 1');
    }

    if (parseInt($routeParams.section) == 2) {//angular.element($document.querySelector('#eventStreet01')).focus()
      //angular.element($document).find('#eventStreet01').focus();
      //$log.info('section 2');
    }

    if (parseInt($routeParams.section) == 3) {//angular.element($document.querySelector('#inviteeName')).focus()
      //eventStreet01angular.element($document).find('#inviteeName').focus();
      //$log.info('section 3');
    }
  }); //take action

  init();
}
"use strict";

meetUpEventApp.controller('LandingPageController', LandingPageController);
LandingPageController.$inject = ['trafficValet'];
/* @ngInject */

function LandingPageController(trafficValet) {
  //	DEFINE LOCAL VARIABLES
  var vm = this;
  var landingSherpa = trafficValet; //	NOTIFY PROGRESS

  console.log('in the landing page'); //local methods
  //vm methods

  vm.createAnAccount = function () {
    landingSherpa.redirectTo('/signup');
  };

  vm.loginUser = function () {
    landingSherpa.redirectTo('/login');
  }; //watchers
  //action

}
"use strict";

meetUpEventApp.controller('MainController', MainController);
MainController.$inject = ['$log', '$location', '$document', '$window'];
/* @ngInject */

function MainController($log, $location, $document, $window) {
  var vm = this;
  var fbURL = 'https://meetupplanner.firebaseio.com/';
  var ref = new Firebase(fbURL);

  function resizeBGImage() {
    var body = angular.element($document);
    $document.css('hight', $window.outerHeight);
  }

  vm.logout = function () {
    alert('logging you out!');
    ref.unauth();
    $location.path('/');
  };

  angular.element($document).ready(function () {
    //FastClick.attach($document.body);
    resizeBGImage();
  });
}
"use strict";

meetUpEventApp.controller('NewUserSignUpController', NewUserSignUpController);
NewUserSignUpController.$inject = ['$scope', '$log', 'validation', 'backendServices', 'trafficValet', 'userData'];
/* @ngInject */

function NewUserSignUpController($scope, $log, validation, backendServices, trafficValet, userData) {
  var vm = this;
  var signupValidation = validation; //define local variables
  //define vm input variables

  vm.name = signupValidation.generateTestableObject('name');
  vm.email = signupValidation.generateTestableObject('email');
  vm.pass = signupValidation.generateTestableObject('pass');

  vm.createNewUser = function () {
    //declare local variables
    var newUserSherpa = trafficValet; //confirm all fields are valid

    if (vm.name.passesAllReqs && vm.email.passesAllReqs && vm.pass.passesAllReqs) {
      //declare local variables
      var createNewUser = backendServices;
      var newUserData = userData;
      var thisUID; //create the new user in the database

      createNewUser.createNewUser(vm.email.value, vm.pass.value).then(function (dbUserData) {
        //maintain local values to speed up user experience
        newUserData.setPrimariesLocally(vm.email.value, vm.name.value, dbUserData.uid); //create a user profile in the database

        createNewUser.addNewUserToDatabase(dbUserData.uid, vm.name.value, vm.email.value).then(function (message) {
          $log.info(message); //add this user to the list of registered users

          createNewUser.addNewUserToRegUsersList(dbUserData.uid, vm.email.value).then(function (message) {
            //redirect using the uid
            //redirect to the next page 
            newUserSherpa.redirectTo('/userInformation', dbUserData.uid);
            $log.info(message);
          })["catch"](function (message) {
            $log.info(message);
          });
        })["catch"](function (message) {
          $log.info(message);
        });
      })["catch"](function (message) {
        $log.info(message);
      });
    }
  }; //run time actions

}
"use strict";

meetUpEventApp.controller('RegUserLoginController', RegUserLoginController);
RegUserLoginController.$inject = ['$log', '$document', 'backendServices', 'trafficValet', 'userData'];
/* @ngInject */

function RegUserLoginController($log, $document, backendServices, trafficValet, userData) {
  var vm = this; //define vm input variables

  vm.inputs = {
    email: '',
    password: '',
    requiredFieldsDefined: false
  };
  vm.errors = {
    message: '',
    passesAllTests: true
  };
  vm.unclockUserLoginBtn = {
    'usable': false,
    'class': {
      'btn': true,
      'btn-warning': true,
      'btn-success': false,
      'col-xs-12': true,
      'col-sm-12': true
    },
    message: 'Need Email & Pass'
  }; //methods

  function openUserLoginBtn() {
    //check that there is an email and there is a password
    if (angular.isDefined(vm.inputs.email) && vm.inputs.email !== '' && angular.isDefined(vm.inputs.password) && vm.inputs.password !== '') {
      vm.inputs.requiredFieldsDefined = true;
      vm.unclockUserLoginBtn["class"]['btn-success'] = true;
      vm.unclockUserLoginBtn["class"]['btn-warning'] = false;
      vm.unclockUserLoginBtn.message = 'Login';
      vm.unclockUserLoginBtn.usable = true;
    } else {
      vm.inputs.requiredFieldsDefined = false;
      vm.unclockUserLoginBtn["class"]['btn-success'] = false;
      vm.unclockUserLoginBtn["class"]['btn-warning'] = true;
      vm.unclockUserLoginBtn.message = 'Need Email & Pass';
      vm.unclockUserLoginBtn.usable = false;
    }
  } //view model methods


  vm.update = function () {
    //set values
    vm.inputs.email = $document.find('#userEmail')[0].value;
    vm.inputs.password = $document.find('#userPassword')[0].value;
    openUserLoginBtn();
  };

  vm.loginRegisteredUser = function () {
    //declare local variables
    var registeredUserSherpa = trafficValet; //confirm all fields are valid

    if (true) {
      //declare local variables
      var database = backendServices;
      var registeredUserData = userData; //verify users credentials

      database.LoginRegisteredUser(vm.inputs.email, vm.inputs.password).then(function (userCredentials) {
        //if no trouble logging in update error object
        vm.errors.passesAllTests = true; //add primary information to local model

        registeredUserData.setPrimariesLocally(vm.inputs.email, vm.inputs.name, userCredentials.uid);
      }).then(function () {
        //$log.info("uid is " + registeredUserData.getUIDLocally());
        database.getUserBio(registeredUserData.getUIDLocally()).then(function (userBio) {
          //update userData model with userBio
          registeredUserData.updateBioLocally(userBio); //load user events

          database.getUserEvents(registeredUserData.getUIDLocally()).then(function (allEventsForThisUser) {
            //update userData model with userEvents
            registeredUserData.updateAllUserEventsLocally(allEventsForThisUser);
          })["catch"](function (message) {
            $log.info(message);
          });
        })["catch"](function (message) {
          $log.info(message);
        }); //redirect to the next page 

        registeredUserSherpa.redirectTo('/userInformation', registeredUserData.getUIDLocally());
      })["catch"](function (message) {
        //if there was an error logging in, let the user know
        vm.errors.message = message;
        vm.errors.passesAllTests = false;
      }); //use uid to collect user bio
    }
  };

  vm.clicked = function () {
    var userAuthentication = backendServices;
    userAuthentication.logUserOut();
  }; //run commands

}
"use strict";

meetUpEventApp.controller('topMenuController', topMenuController);
topMenuController.$inject = ['$scope', '$log', '$location', '$document', '$window'];
/* @ngInject */

function topMenuController($scope, $log, $location, $document, $window) {
  var vm = this;
  var fbURL = 'https://meetupplanner.firebaseio.com/';
  var ref = new Firebase(fbURL); //local variables

  vm.loggedIn = false; //styles variables
  //event listeners

  if ('addEventListener' in $document) {
    $document.addEventListener('DOMContentLoaded', function () {
      //$log.info('adding FastClick');
      FastClick.attach($document.body);
    }, false);
  }

  angular.element($window).bind('resize', function () {
    vm.onResizeFunction();
    $scope.$apply();
  });
  angular.element($document).ready(function () {
    if ($window.outerWidth < 600) {
      vm.onResizeFunction();
      $scope.$apply();
    }
  }); //dynamically set input width
  // Create a callback which logs the current auth state

  function init() {
    vm.onResizeFunction();
    $scope.$apply();
  }

  function authDataCallback(authData) {
    if (authData) {
      //$log.info("User " + authData.uid + " is logged in with " + authData.provider);
      vm.loggedIn = true;
    } else {
      //$log.info("User is logged out");
      vm.loggedIn = false;
    }
  }

  function redirect(path, userData) {
    var fullPath = path + '/' + userData.uid + '/' + userData.token; //redirect
    //$log.info('redirecting to: ' + fullPath);

    $location.path(fullPath); //$scope.$apply();
  } //vm accessible methods


  vm.logout = function () {
    //$log.info('logging out!');
    vm.loggedIn = false;
    ref.unauth();
    redirect('/', {
      uid: '',
      token: ''
    });
  };

  vm.navBarLoginRegisteredUser = function () {
    //$log.info('launching login');
    if (true) {
      //if(vm.unclockUserLoginBtn.usable) {
      //define local variable
      var ref = new Firebase(fbURL); //authenticate the user

      ref.authWithPassword({
        email: vm.navbarUserEmail,
        password: vm.navbarUserPass
      }, function (error, authData) {
        if (error) {
          $log.info('Error Logging In: ' + error);
        } else {
          $log.info('Logged In successfully: ' + authData.uid); //$log.info(authData);
          //save all the data
          //load user bio
          //load user events
          //redirect

          redirect('/userInformation', authData);
          $scope.$apply(); //click closed the navbar

          angular.element('.navbar-toggle').click();
        }
      });
    }
  };

  vm.onResizeFunction = function () {
    var navbarInputs = angular.element('.navbarInputs');
    navbarInputs.css('width', $window.outerWidth - 26 + 'px');
  }; // Register the callback to be fired every time auth state changes


  ref.onAuth(authDataCallback);
}
"use strict";

meetUpEventApp.controller('UserEventsController', UserEventsController);
UserEventsController.$inject = ['$log', '$routeParams', 'userData', 'trafficValet'];
/* @ngInject */

function UserEventsController($log, $routeParams, userData, trafficValet) {
  var vm = this;
  var currentUser = userData; //local view variables

  vm.showDecline = false; //what is this being used for?

  vm.userBio = {};
  vm.events = {};
  vm.sectionAvailable = {
    pending: false,
    attending: false,
    hosting: false,
    completed: false
  };
  vm.errors = {}; //declare local methods

  function unixTimeToDateTime(unixTime) {
    return new Date(parseInt(unixTime));
  }

  ;

  function dateTimeToUnixTime(dateTime) {
    return Date.parse(dateTime);
  }

  ;

  function noOfHosteEvents() {
    //declare local variable
    var counter = 0;

    for (event in vm.events.hosting) {
      counter++;
    }

    return counter;
  }

  function generateEventID() {
    //declare local variables
    var date = new Date();
    var eventID = dateTimeToUnixTime(date) * 10 + noOfHosteEvents();
    return eventID;
  }

  function checkForEvents() {
    //loop through all the event categories
    Object.keys(vm.events).forEach(function (category) {
      //inside each category count the number of event objects...NOT updated placeholder though
      Object.keys(vm.events[category]).forEach(function (eventID) {
        //declare local variable
        var counter = 0; //count events with id's / NOT 'updated' placeholders

        if (angular.isObject(vm.events[category][eventID])) counter++; //if at least one event id (object) was counted, then show the section

        if (counter > 0) vm.sectionAvailable[category] = true;else vm.sectionAvailable[category] = false;
      });
    });
  }

  function initialize() {
    //make sure the uid is set
    currentUser.setUIDLocally($routeParams.uid); //load the user bio

    currentUser.loadBio($routeParams.uid).then(function (retrievedBio) {
      vm.userBio = retrievedBio;
    })["catch"](); //load user events progressivley
    //first whatever is in the model already

    vm.events = currentUser.getAllUserEventsLocally(); //$log.info(vm.events);
    //then call to the db and get the most up to date info

    currentUser.getRemoteEventsForLocal().then(function (obtainedUserEvents) {
      //$log.info(obtainedUserEvents);
      //update the view model with the updated DB results
      vm.events = currentUser.getAllUserEventsLocally(); //take out the updated object to clean up for new users

      delete vm.events.pending.updated;
      delete vm.events.pending[undefined];
      var count = 0;
      Object.keys(vm.events.hosting).forEach(function (key) {
        count++;
      }); //take away for hosting also

      if (count > 1) {
        delete vm.events.hosting.updated;
        delete vm.events.hosting[undefined];
      }
    }).then(function () {
      //now that events are loaded, reflect it in the view model
      checkForEvents();
    });
  } //declare view methods


  vm.createNewEvent = function () {
    //define local variables
    var eventID = generateEventID();
    var newEventSherpa = trafficValet; //add the event to the modal (locally ONLY)

    currentUser.createNewEvent(eventID);
    /*.then(function(affirmativeResponse) {
    	//report the success
    	$log.info(affirmativeResponse);
    })
    .then(function() {
    	//if there was an updated field, remove it now
    	currentUser.cleanDBEventsCategory('hosting');
    	})
    .catch(function(errorResponse) {
    	//report the error
    	$log.info(errorResponse);
    })*/
    //redirect to the new event page		

    newEventSherpa.redirectTo('/event', eventID, currentUser.getUIDLocally(), currentUser.getUIDLocally());
  }; //execute scripts


  initialize();
}
"use strict";

meetUpEventApp.controller('UserInformationController', UserInformationController);
UserInformationController.$inject = ['$log', '$document', '$routeParams', 'userData', 'trafficValet'];
/* @ngInject */

function UserInformationController($log, $document, $routeParams, userData, trafficValet) {
  var vm = this; //local variables

  var currentUser = userData; //view model variables

  vm.user = {};
  vm.tempBirthday;
  vm.view = {
    dataToSave: false,
    isData: false,
    btnMssg: 'Move On...',
    proceedBtn: 'btn btn-primary'
  }; //local methods

  function unixTimeToDateTime(unixTime) {
    return new Date(parseInt(unixTime));
  }

  ;

  function dateTimeToUnixTime(dateTime) {
    return Date.parse(dateTime);
  }

  ;

  function buildTempBirthday() {
    var newBirthday = new Date(); //round to the nearest hour, cut off anything smaller

    newBirthday.setHours(0);
    newBirthday.setMinutes(0);
    newBirthday.setSeconds(0);
    newBirthday.setMilliseconds(0);
    vm.tempBirthday = newBirthday;
  } //view accessible methods


  vm.checkValues = function () {
    //throw the isData flag if something is updated
    vm.view.isData = true;

    if (!(angular.isUndefined(vm.user.company) || vm.user.company === '') || !(angular.isUndefined(vm.user.title) || vm.user.title === '') || !(angular.isUndefined(vm.user.dob) || vm.user.dob === '')) {
      vm.view.dataToSave = true;
      vm.view.proceedBtn = 'btn btn-success';
      vm.view.btnMssg = 'Save & Continue';
    } else {
      vm.view.dataToSave = false;
      vm.view.proceedBtn = 'btn btn-primary';
      vm.view.btnMssg = 'Move On...';
    }
  };

  vm.updateDOB = function () {
    vm.user.dob = dateTimeToUnixTime(vm.tempBirthday);
    vm.checkValues();
  };

  vm.saveAndMoveOn = function () {
    //local variables
    var userInfoSherpa = trafficValet;
    var currentUid = currentUser.getUIDLocally(); //convert DOB to unixTime and save

    if (vm.tempBirthday !== 0) vm.updateDOB(); //if there isn't currently a dob, grab from the route params

    if (currentUid == '' || angular.isUndefined(currentUid)) {
      currentUser.setUIDLocally($routeParams.uid);
    } //if there is new data, save it


    if (vm.view.isData) {
      //$log.info('saving the new data');
      currentUser.updateBioLocally(vm.user);
    } //move on


    userInfoSherpa.redirectTo('/userEvents', vm.user.uid);
  };

  function initialize() {
    //load FastClick
    //FastClick.attach($document.body);
    buildTempBirthday(); //load userData locally or from db

    currentUser.loadBio($routeParams.uid).then(function (obtainedUserData) {
      //assign user values
      vm.user = obtainedUserData; //build tempBirthday

      if (angular.isDefined(obtainedUserData.dob) && obtainedUserData.dob !== '') {
        vm.tempBirthday = unixTimeToDateTime(obtainedUserData.dob);
      }
    });
  } //run processes


  initialize(); //with internet use the event listener instead
}
"use strict";

/* AddAGuest.directive.js */

/**
* @desc displays a list of all guests invited to an event this user is hosting.
* @example <add-a-guest></add-a-guest>
*/
angular.module('meetUpEventApp').directive('addAGuest', addAGuest);
/* @ngInject */

function addAGuest() {
  linkFunc.$inject = ["scope", "el", "attr", "ctrl"];
  var directive = {
    restrict: 'AECM',
    templateUrl: 'views/directives/addAGuest.directive.htm',
    replace: true,
    scope: {
      guestList: '='
    },
    link: linkFunc,
    controller: addAGuestController,
    controllerAs: 'vm',
    bindToController: true
  };
  /* @ngInject */

  function linkFunc(scope, el, attr, ctrl) {}

  addAGuestController.$inject = ['$log', '$routeParams', 'validation', 'userData'];
  /* @ngInject */

  function addAGuestController($log, $routeParams, validation, userData) {
    var vm = this;
    var emailChecker = validation;
    var invitationManager = userData; //local variables

    var eventDetails = {}; //vm variables

    vm.tempGuest = {
      name: '',
      email: '',
      status: 'pending'
    };
    vm.validations = {
      name: {
        addressed: false,
        valid: false,
        errorMessage: ''
      },
      email: {
        addressed: false,
        valid: false,
        errorMessage: ''
      },
      invitation: {
        isTheHost: false,
        alreadyInvited: false,
        errorMessage: ''
      }
    };
    vm.invitationValidForSubmission = false;
    vm.submissionButton = {
      style: {
        color: 'red'
      },
      "class": {
        'col-xs-12': true,
        'col-sm-12': true,
        'btn': true,
        'btn-warning': true,
        'btn-success': false
      },
      message: 'Address Invitation...'
    }; //local methods

    function utf8_to_b64(str) {
      return btoa(str);
    }

    function validateInvitation() {
      //check if both inputs are valid
      if (vm.validations.name.valid && vm.validations.email.valid) {
        //set the validity flag
        vm.invitationValidForSubmission = true; //update the submission button

        vm.submissionButton["class"]['btn-warning'] = false;
        vm.submissionButton["class"]['btn-success'] = true;
        vm.submissionButton.message = 'Invite Guest';
      } else {
        //set the validity flag
        vm.invitationValidForSubmission = false; //update the submission button

        vm.submissionButton["class"]['btn-warning'] = true;
        vm.submissionButton["class"]['btn-success'] = false;
        vm.submissionButton.message = 'Address Invitation...';
      }
    }

    function init() {
      //load the event for reference
      if (angular.isUndefined(invitationManager.getOneUserEventLocally('hosting', $routeParams.eventId))) {
        //if this page was loaded before the model get the event
        invitationManager.getRemoteEventsForLocal().then(function () {
          //when the event has been loaded
          eventDetails = invitationManager.getOneUserEventLocally('hosting', $routeParams.eventId);
        });
      } else {
        //just get the model locally
        eventDetails = invitationManager.getOneUserEventLocally('hosting', $routeParams.eventId);
      }
    } //vm methods


    vm.validateName = function () {
      //this field is being edited, throw flag
      vm.validations.name.addressed = true; //check for value

      if (angular.isDefined(vm.tempGuest.name) && vm.tempGuest.name != '') {
        vm.validations.name.valid = true;
        vm.validations.name.errorMessage = '';
      } else {
        vm.validations.name.valid = false;
        vm.validations.name.errorMessage = 'This guest needs a name';
      }

      validateInvitation();
    };

    vm.validateEmail = function () {
      //this field is being edited, throw flag
      vm.validations.email.addressed = true; //is there an email value?

      if (angular.isDefined(vm.tempGuest.email) && vm.tempGuest.email != '') {
        //if an email exists check it's validity
        if (angular.isUndefined(emailChecker.email(vm.tempGuest.email))) {
          //email is valid
          vm.validations.email.valid = true;
          vm.validations.email.errorMessage = '';
        } else {
          //get the error
          vm.validations.email.valid = false;
          vm.validations.email.errorMessage = emailChecker.email(vm.tempGuest.email); //$log.info(vm.validations.email.errorMessage);
        }
      } else {
        //there isn't an email yet
        vm.validations.email.valid = false;
        vm.validations.email.errorMessage = 'Not a valid email';
      }

      validateInvitation();
    };

    vm.showNameError = function () {
      if (!vm.validations.name.valid && vm.validations.name.addressed) return true;else return false;
    };

    vm.showEmailError = function () {
      if (!vm.validations.email.valid && vm.validations.email.addressed) return true;else return false;
    };

    vm.showInvitationError = function () {
      if (vm.validations.invitation.isTheHost || vm.validations.invitation.alreadyInvited) return true;else return false;
    };

    vm.submitGuestInvitation = function () {
      //if the requirnments are fulfilled...
      if (vm.invitationValidForSubmission) {
        //make sure the invitation is not to the current user
        if (invitationManager.thisIsTheHostEmail(vm.tempGuest.email, $routeParams.eventId)) {
          vm.validations.invitation.isTheHost = true;
          vm.validations.invitation.errorMessage = 'No need to invite the host';
          return 0;
        } else {
          vm.validations.invitation.isTheHost = false;
        } //make sure this person has not already been invited

        /*
        if(invitationManager.guestInvitedAlready(vm.tempGuest.email, $routeParams.eventId)) {
        	vm.validations.invitation.alreadyInvited = true;
        vm.validations.invitation.errorMessage = 'This guest has already been invited';
        return 0;
        } else {
        	vm.validations.invitation.alreadyInvited = false;
        }*/
        //if this person is a registered user get their user id


        invitationManager.getUserIdForGuest(vm.tempGuest.email).then(function (uid) {
          return uid;
        }).then(function (uid) {
          //use that uid to register the user
          //add the person to the host's LOCAL guest list
          if (!angular.isObject(vm.guestList)) {
            vm.guestList = {};
          } //create the guest to save


          var guestBeingAdded = vm.tempGuest;
          vm.guestList[uid] = guestBeingAdded;
          vm.tempGuest = {
            name: '',
            email: '',
            status: 'pending'
          };
        }).then(function () {//add this event to the users' pending list

          /*invitationManager.updatePendingEventsListForUser()*/
        }).then(function () {//remove the 'updated' field if need be
        })["catch"](function (errorMessage) {
          //assuming no uid was found just use the email
          $log.info(errorMessage); //create the emailId

          idByEmail = utf8_to_b64(vm.tempGuest.email); //add this person to the host's guest list

          if (!angular.isObject(vm.guestList)) {
            vm.guestList = {};
          } //create the guest to save


          var guestBeingAdded = vm.tempGuest;
          vm.guestList[idByEmail] = guestBeingAdded;
          /*invitationManager.addGuestToHostGuestList(vm.tempGuest.name, vm.tempGuest.email, undefined, $routeParams.eventId, $routeParams.uid)
          .then(function(positiveResult) {
          	$log.info('got this result: ' + positiveResult);
          })
          .then(function() {
          	//add this event to the guest's pending list
          	invitationManager.updatePendingEventsListForGuest($routeParams.eventId)
          })
          .then(function() {
          //remove the 'updated' field if need be
          })
          .catch(function(negativeResult) {
          	$log.info('got this result: ' + positiveResult);
          })*/

          vm.tempGuest = {
            name: '',
            email: '',
            status: 'pending'
          };
        });
      }
    }; //actions


    init();
  }

  return directive;
}

;
"use strict";

/* focusMe.directive.js */

/**
* @desc displays a list of all guests invited to an event this user is hosting.
* @example <input type="text" focus-me="shouldBeOpen">
*/
angular.module('meetUpEventApp').directive('focusMe', focusMe);
focusMe.$inject = ['$timeout', '$parse', '$log'];
/* @ngInject */

function focusMe($timeout, $parse, $log) {
  var focusMeDirective = {
    //
    link: function link(scope, element, attrs) {
      var model = $parse(attrs.focusMe);
      scope.$watch(model, function (value) {
        //$log.info('value=',value);
        if (value === true) {
          $timeout(function () {
            element[0].focus();
          });
        }
      });
      element.bind('blur', function () {//$log.info('blur');
        //scope.$apply(model.assign(scope, false));
      });
    }
  };
  return focusMeDirective;
}
"use strict";

/* HostedEventsList.directive.js */

/**
* @desc displays a list of all the events the current user is hosting.
* @example <hosted-events-list></hosted-events-list>
*/
angular.module('meetUpEventApp').directive('hostedEventsList', hostedEventsList);
/* @ngInject */

function hostedEventsList() {
  linkFunc.$inject = ["scope", "el", "attr", "ctrl"];
  var directive = {
    restrict: 'AECM',
    templateUrl: 'views/directives/hostedEventsList.directive.htm',
    replace: true,
    scope: {
      hostedEvents: '=',
      userId: '='
    },
    link: linkFunc,
    controller: hostedEventsListController,
    controllerAs: 'vm',
    bindToController: true
  };
  /* @ngInject */

  function linkFunc(scope, el, attr, ctrl) {
    scope.$watch('hostedEvents', function (next, current) {//something
    });
  }

  hostedEventsListController.$inject = ['$log', 'trafficValet'];
  /* @ngInject */

  function hostedEventsListController($log, trafficValet) {
    var vm = this; //local variables

    var hostedEventsSherpa = trafficValet; //view model variables

    vm.guestsAreInvited = false; //local methods

    function unixTimeToDateTime(unixTime) {
      return new Date(parseInt(unixTime));
    }

    ;

    function countGuests(list) {
      //declare local variable
      var counter = 0; //if we're counting, then there's a list, so throw the flag

      vm.guestsAreInvited = true;
      Object.keys[list].forEach(function (guest) {
        counter++;
      });
      return counter;
    } //view model methods


    vm.formatDate = function (unixTime) {
      //reformat the time
      return unixTimeToDateTime(unixTime);
    };

    vm.guestsAttending = function (guestList) {
      if (angular.isDefined(guestList)) {
        if (angular.isDefined(guestList['attending'])) return countGuests(guestList['attending']);else return 0;
      } else return 0;
    };

    vm.guestsInvited = function (guestList) {
      if (angular.isDefined(guestList)) {
        //local methods
        var totalGuestCount = function totalGuestCount() {
          return guestCount.attending + guestCount.pending + guestCount.declined;
        }; //check values


        //declare local variables
        var guestCount = {
          attending: 0,
          pending: 0,
          declined: 0
        };
        if (angular.isDefined(guestList['attending'])) guestCount.attending = countGuests(guestList['attending']);
        if (angular.isDefined(guestList['pending'])) guestCount.pending = countGuests(guestList['pending']);
        if (angular.isDefined(guestList['declined'])) guestCount.declined = countGuests(guestList['declined']);
        return totalGuestCount();
      } else return 0;
    };

    vm.percentageAttending = function (guestList) {
      if (angular.isDefined(guestList)) {
        return guestsAttending(guestlist) / guestsInvited(guestList);
      } else return 0;
    };

    vm.eventClicked = function (eventID) {
      //redirect to the event page
      //$log.info('redirecting to: /event/' + eventID + '/' + vm.hostedEvents[eventID].host.uid + '/' + vm.userId);
      hostedEventsSherpa.redirectTo('/event', eventID, vm.hostedEvents[eventID].host.uid, vm.userId);
    };

    vm.inviteGuests = function (eventId) {
      hostedEventsSherpa.redirectTo('/event/host', eventId, vm.hostedEvents[eventId].host.uid, '3');
    }; //actions

  }

  return directive;
}

;
"use strict";

/* HostedGuestList.directive.js */

/**
* @desc displays a list of all guests invited to an event this user is hosting.
* @example <hosted-guest-list></hosted-guest-list>
*/
angular.module('meetUpEventApp').directive('hostedGuestList', hostedGuestList);
/* @ngInject */

function hostedGuestList() {
  linkFunc.$inject = ["scope", "el", "attr", "ctrl"];
  var directive = {
    restrict: 'AECM',
    templateUrl: 'views/directives/hostedGuestList.directive.htm',
    replace: true,
    scope: {
      guestList: '='
    },
    link: linkFunc,
    controller: hostedGuestListController,
    controllerAs: 'vm',
    bindToController: true
  };
  /* @ngInject */

  function linkFunc(scope, el, attr, ctrl) {
    scope.$watch('guestList', function () {
      scope.$apply;
    });
  }

  hostedGuestListController.$inject = ['$log', '$routeParams', 'userData'];
  /* @ngInject */

  function hostedGuestListController($log, $routeParams, userData) {
    var vm = this; //local variables

    vm.isAGuestList = false; //local methods

    function thereIsAGuestList() {
      //check for a guestList object
      if (angular.isDefined(vm.guestList) && vm.guestList != '') {
        vm.isAGuestList = true;
        return true;
      } else {
        vm.isAGuestList = false;
        return false;
      }
    }

    function init() {
      //local variables
      var listCollector = userData; //if there isn't a guest list, go out to the db to get it

      if (!thereIsAGuestList()) {
        //$log.info('going after the list');
        listCollector.getEventGuestList($routeParams.uid, $routeParams.eventId).then(function (returnedList) {
          //$log.info('got the list');
          //$log.info(returnedList);
          vm.guestList = returnedList;
          if (angular.isObject(returnedList)) vm.isAGuestList = true;
        })["catch"](function (error) {//$log.info('There was an error: '+ error);
        });
      }
    } //vm methods
    //actions


    init();
  }

  return directive;
}

;
"use strict";

/* PendingEventsList.directive.js */

/**
* @desc displays a list of all the events the current user is hosting.
* @example <pending-events-list></pending-events-list>
*/
angular.module('meetUpEventApp').directive('pendingEventsList', pendingEventsList);
/* @ngInject */

function pendingEventsList() {
  linkFunc.$inject = ["scope", "el", "attr", "ctrl"];
  var directive = {
    restrict: 'AECM',
    templateUrl: 'views/directives/pendingEventsList.directive.htm',
    replace: true,
    scope: {
      pendingEvents: '=',
      userId: '='
    },
    link: linkFunc,
    controller: pendingEventsListController,
    controllerAs: 'vm',
    bindToController: true
  };
  /* @ngInject */

  function linkFunc(scope, el, attr, ctrl) {
    scope.$watch('hostedEvents', function (next, current) {//something
    });
  }

  pendingEventsListController.$inject = ['$log', 'trafficValet'];
  /* @ngInject */

  function pendingEventsListController($log, trafficValet) {
    var vm = this; //local variables
    //view model variables

    vm.pendingEvents = {}; //local methods

    function unixTimeToDateTime(unixTime) {
      return new Date(parseInt(unixTime));
    }

    ;

    function dateTimeToUnixTime(dateTime) {
      return Date.parse(dateTime);
    }

    ;

    function buildTomorrowDate() {
      var today = new Date(); //round to the nearest hour, cut off anything smaller

      today.setHours(today.getHours() + Math.round(today.getMinutes() / 60));
      today.setMinutes(0);
      today.setSeconds(0);
      today.setMilliseconds(0);
      today = dateTimeToUnixTime(today);
      var tomorrow = today + 1000 * 60 * 60 * 24;
      return tomorrow;
    }

    function addWelcomeEvent() {
      vm.pendingEvents = {
        welcome: {
          name: 'Meet-up Event Planner Welcome Event',
          message: 'Thanks for trying out Meet-up Event Planner!  Click here to learn more.',
          eventTimes: {
            end: buildTomorrowDate() + 1000 * 60 * 60 * 3,
            start: buildTomorrowDate()
          },
          rsvped: false,
          accepted: false,
          accept: function accept() {
            this.rsvped = true;
            this.accepted = true;
          },
          decline: function decline() {
            this.rsvped = true;
            this.accepted = false;
          }
        }
      };
    } //view model methods


    vm.eventClicked = function () {};

    vm.formatDate = function (unixTime) {
      return unixTimeToDateTime(unixTime);
    }; //take action


    addWelcomeEvent();
  }

  return directive;
}

;
"use strict";

/* ToolBar.directive.js */

/**
* @desc toolbar directive that is used on the main page across the entire app.
* @example <div tool-bar></div>
*/
angular.module('meetUpEventApp').directive('toolBar', toolBar);
/* @ngInject */

function toolBar() {
  linkFunc.$inject = ["scope", "el", "attr", "ctrl"];
  var directive = {
    restrict: 'AECM',
    templateUrl: 'views/directives/toolBar.directive.htm',
    replace: true,
    scope: {},
    link: linkFunc,
    controller: ToolBarController,
    controllerAs: 'vm',
    bindToController: true
  };
  /* @ngInject */

  function linkFunc(scope, el, attr, ctrl) {}

  ToolBarController.$inject = ['$scope', '$log', 'backendServices', 'trafficValet'];
  /* @ngInject */

  function ToolBarController($scope, $log, backendServices, trafficValet) {
    var vm = this; //local controler variables

    var fbConnect = backendServices;
    var toolbarSherpa = trafficValet; //local view variables

    function checkLoginStatus() {
      fbConnect.checkLoginStatus().then(function (status) {
        vm.loggedIn = status;
      })["catch"]();
    } //vm methods


    vm.login = function () {};

    vm.logout = function () {
      //$log.info('logging out');
      //logout
      fbConnect.logUserOut(); //redirect

      toolbarSherpa.redirectTo('/login');
    };

    vm.loginRegisteredUser = function () {
      //declare local variables
      var registeredUserSherpa = trafficValet; //confirm all fields are valid

      if (true) {
        //declare local variables
        var database = backendServices;
        var registeredUserData = userData; //verify users credentials

        database.LoginRegisteredUser(vm.email, vm.password).then(function (userCredentials) {
          //if no trouble logging in update error object
          //vm.errors.passesAllTests = true;
          //add primary information to local model
          //registeredUserData.setPrimariesLocally(userCredentials.email, userCredentials.name, userCredentials.uid);
          return userCredentials.uid;
        }).then(function (uid) {
          database.getUserBio(uid).then(function (userBio) {
            //update userData model with userBio
            registeredUserData.updateBioLocally(userBio); //load user events

            database.getUserEvents(uid).then(function (allEventsForThisUser) {
              //update userData model with userEvents
              registeredUserData.updateAllUserEventsLocally(allEventsForThisUser);
            })["catch"](function (message) {
              $log.info(message);
            });
          })["catch"](function (message) {
            $log.info(message);
          }); //redirect to the next page 

          registeredUserSherpa.redirectTo('/userInformation', uid);
        })["catch"](function (message) {//if there was an error logging in, let the user know
          //vm.errors.message = message;
          //vm.errors.passesAllTests = false;
        }); //use uid to collect user bio
      }
    }; //actions


    checkLoginStatus(); //watchers

    $scope.$on('$routeChangeStart', function (next, current) {
      checkLoginStatus();
    });
  }

  return directive;
}

;
"use strict";

angular.module('meetUpEventApp').factory('authService', authService);
authService.$inject = ['$log', 'backendServices'];
/* @ngInject */

function authService($log, backendServices) {
  var allAuthServices = {
    isLoggedIn: isLoggedIn
  };

  function isLoggedIn() {
    //check the user authenticaion state
    var dbAuthentication = backendServices;
    dbAuthentication.checkLoginStatus().then(function (status) {
      return status;
    })["catch"](function (status) {
      return status;
    });
  }

  return allAuthServices;
}
"use strict";

angular.module('meetUpEventApp').factory('backendServices', backendServices);
backendServices.$inject = ['$log', '$q', '$window'];
/* @ngInject */

function backendServices($log, $q, $window) {
  //declare local variables
  var fbURL = 'https://meetupplanner.firebaseio.com/';
  var allBackendServices = {
    utf8_to_b64: utf8_to_b64,
    //local functions to convert dates
    b64_to_utf8: b64_to_utf8,
    unixTimeToDateTime: unixTimeToDateTime,
    dateTimeToUnixTime: dateTimeToUnixTime,
    LoginRegisteredUser: LoginRegisteredUser,
    //authenticaion
    checkLoginStatus: checkLoginStatus,
    logUserOut: logUserOut,
    downloadUserData: downloadUserData,
    //getter methods
    getUserBio: getUserBio,
    getUserEvents: getUserEvents,
    getAHostedEvent: getAHostedEvent,
    getAnInvitedEvent: getAnInvitedEvent,
    findGuestUID: findGuestUID,
    getGuestListForEvent: getGuestListForEvent,
    createNewUser: createNewUser,
    //setter Methods
    addNewUserToDatabase: addNewUserToDatabase,
    addNewUserToRegUsersList: addNewUserToRegUsersList,
    uploadUserData: uploadUserData,
    uploadUserBio: uploadUserBio,
    createHostedEvent: createHostedEvent,
    addGuestToHostGuestListonDB: addGuestToHostGuestListonDB,
    //addPendingEventForUser: addPendingEventForUser,
    //addPendingEventForGuest: addPendingEventForGuest,
    deleteUpdateField: deleteUpdateField,
    //delete methods
    removeIncompleteEvent: removeIncompleteEvent,
    thereWasAnUpdateField: thereWasAnUpdateField //model maintainance

  };

  function utf8_to_b64(str) {
    return btoa(str);
  }

  function b64_to_utf8(str) {
    return atob(str);
  }

  function unixTimeToDateTime(unixTime) {
    return new Date(parseInt(unixTime));
  }

  function dateTimeToUnixTime(dateTime) {
    return Date.parse(dateTime);
  }

  function createNewUser(email, password) {
    //declare local variables
    var fireBaseAccounts = new Firebase(fbURL); //return a promise

    return $q(function (resolve, reject) {
      fireBaseAccounts.createUser({
        email: email,
        password: password
      }, function (error, userData) {
        if (error) reject('Error creating user: ' + error);else resolve(userData);
      });
    });
  }

  function addNewUserToDatabase(uid, name, email) {
    //declare local variables
    var app = new Firebase(fbURL);
    var appUsers = app.child('Users').child(uid);
    var currentDate = new Date(); //return a promise

    return $q(function (resolve, reject) {
      appUsers.set({
        'bio': {
          'uid': uid,
          'name': name,
          'email': email
        },
        'events': {
          'pending': {
            'updated': dateTimeToUnixTime(currentDate)
          },
          'hosting': {
            'updated': dateTimeToUnixTime(currentDate)
          },
          'attending': {
            'updated': dateTimeToUnixTime(currentDate)
          },
          'completed': {
            'updated': dateTimeToUnixTime(currentDate)
          }
        }
      }, function (error) {
        if (error) reject('Data could not be saved: ' + error);else resolve('Data saved successfully.');
      });
    });
  }

  function addNewUserToRegUsersList(uid, email) {
    //declare local variables
    var app = new Firebase(fbURL);
    var b64Email = utf8_to_b64(email);
    var RegisteredUsersList = app.child('Uids').child(b64Email); //return a promise

    return $q(function (resolve, reject) {
      RegisteredUsersList.set(uid, function (error) {
        if (error) reject("Data could not be saved. " + error);else resolve("uid created sucessfully.");
      });
    });
  }

  function LoginRegisteredUser(email, password) {
    //declare local variables
    var app = new Firebase(fbURL);
    return $q(function (resolve, reject) {
      //authenticate the user
      app.authWithPassword({
        email: email,
        password: password
      }, function (error, authData) {
        if (error) {
          reject('Error Logging In: ' + error);
        } else {
          //$log.info('Logged In successfully: ' + authData.uid);
          resolve(authData);
        }
      });
    });
  }

  function checkLoginStatus() {
    //declare local variables
    var app = new Firebase(fbURL);
    return $q(function (resolve, reject) {
      app.onAuth(function (authData) {
        if (authData) {
          //$log.info("User " + authData.uid + " is logged in with " + authData.provider);
          resolve(true);
        } else {
          //$log.info("User is logged out");
          resolve(false);
        }
      });
    });
  }

  function logUserOut() {
    //declare local variables
    var app = new Firebase(fbURL);
    $log.info('logging user out');
    app.unauth();
  }

  function uploadUserData(allUserData) {
    //declare local variables
    var app = new Firebase(fbURL);
    var uid = allUserData.uid;
    var remoteUser = app.child('Users').child(uid); //return the promise

    return $q(function (resolve, reject) {
      //the actual call
      remoteUser.update(allUserData, function (error) {
        if (error) reject('There was a problem updating that record: ' + error);else resolve('all user data uploaded successfully');
      });
    });
  }

  function uploadUserBio(currentUserBio) {
    //declare local variables
    var app = new Firebase(fbURL);
    var uid = currentUserBio.uid.toString();
    var remoteUserBio = app.child('Users').child(uid).child('bio'); //return the promise

    return $q(function (resolve, reject) {
      //call to the db
      remoteUserBio.update(currentUserBio, function (error) {
        if (error) reject('There was a problem updating that record: ' + error);else resolve('all user bio data uploaded successfully');
      });
    });
  }

  function downloadUserData() {}

  function getUserBio(uid) {
    //declare local variables
    var app = new Firebase(fbURL);
    var userBio = app.child('Users').child(uid).child('bio'); //return the promise

    return $q(function (resolve, reject) {
      //the actual call
      userBio.once('value', function (snapshot) {
        //when the call is successful return the data
        resolve(snapshot.val());
      }, function (error) {
        if (error) {
          reject(error);
        }
      });
    });
  }

  function createHostedEvent(uid, newEvent) {
    //declare local variables
    var app = new Firebase(fbURL);
    var eventID = newEvent.id;
    var newHostedEvent = app.child('Users').child(uid).child('events').child('hosting').child(eventID); //return the promise

    return $q(function (resolve, reject) {
      //call to firebase
      newHostedEvent.set(newEvent, function (error) {
        if (error) reject('There was an error: ' + error);else resolve('New event saved to DB successfully');
      });
    });
  }

  function addGuestToHostGuestListonDB(name, guiestId, eventId, uid) {
    //declare local variables
    var app = new Firebase(fbURL);
    var guestList = app.child('Users').child(uid).child('events').child('hosting').child(eventId).child('guestList').child(guiestId); //return the promise

    return $q(function (resolve, reject) {
      //call to the db
      guestList.set({
        rsvpd: false,
        status: 'pending',
        name: name
      }, function (error) {
        if (error) reject('There was an error: ' + error);else resolve('New event saved to DB successfully');
      });
    });
  }

  function getUserEvents(uid) {
    //declare local variables
    var app = new Firebase(fbURL);
    var userEvents = app.child('Users').child(uid).child('events'); //return the promise

    return $q(function (resolve, reject) {
      //the actual call
      userEvents.orderByKey().once('value', function (snapshot) {
        var userProfile = snapshot.val(); //when the call is successful return the data

        var eventsPackage = {
          hosting: userProfile.hosting,
          attending: userProfile.attending,
          pending: userProfile.pending,
          completed: userProfile.completed
        };
        resolve(eventsPackage);
      }, function (error) {
        if (error) {
          reject(error);
        }
      });
    });
  }

  function getAHostedEvent(uid, eventId) {
    //declare local variables
    var app = new Firebase(fbURL);
    var hostedEvent = app.child('Users').child(uid).child('events').child('hosting').child(eventId); //return the promise

    return $q(function (resolve, reject) {
      //the actual call
      hostedEvent.once('value', function (snapshot) {
        var selectEvent = snapshot.val();
        resolve(selectEvent);
      }, function (error) {
        if (error) reject(error);
      });
    });
  }

  function findGuestUID(guestb64Email) {
    //declare local variables
    var app = new Firebase(fbURL);
    var uids = app.child('Uids'); //return the promise

    return $q(function (resolve, reject) {
      //call to db
      uids.once('value', function (snapshot) {
        //distill results
        var allUsers = snapshot.val();
        Object.keys(allUsers).forEach(function (key) {
          //check each user
          if (key == guestb64Email) {
            resolve(allUsers[key]);
          } else {
            reject('No user by that email');
          }
        });
      });
    });
  }

  function getGuestListForEvent(hostId, eventId) {
    //declare local variables
    var app = new Firebase(fbURL);
    var guestList = app.child('Users').child(hostId).child('events').child('hosting').child(eventId).child('guestList');
    return $q(function (resolve, reject) {
      //call the db
      guestList.once('value', function (snapshot) {
        //local variable
        var theList = snapshot.val();
        resolve(theList);
      }, function (error) {
        if (error) reject('There was an error getting the guest list: ' + error);
      });
    });
  }

  function getAnInvitedEvent(hostId, uid, eventId) {}
  /*
  function addPendingEventForUser(uid, hostId, eventId, event) {
  	//declare local variables
  	var app = new Firebase(fbURL);
  	var userPendingList = app.child('Users').child(uid).child('events').child('pending');
  		//mange the promise
  	return $q(function(resolve, reject) {
  			//call the db
  		userPendingList.set({
  			hostId: {
  				eventId: {
  					event
  				}
  			}
  		}, function(error) {
  			if(error) reject("Error adding to user pending list: " + error);
  			else return resolve('Added to user pending list successfully');
  		})
  		});
  	}
  	function addPendingEventForGuest(uid, hostId, eventId, event) {
  	//declare local variables
  	var app = new Firebase(fbURL);
  	var guestsPendingList = app.child('Unregistered').child(uid).child('events').child('pending');
  		//mange the promise
  	return $q(function(resolve, reject) {
  			//call the db
  		userPendingList.set({
  			hostId: {
  				eventId: {
  					event
  				}
  			}
  		}, function(error) {
  			if(error) reject("Error adding to user pending list: " + error);
  			else return resolve('Added to user pending list successfully');
  		})
  		});
  	}*/


  function deleteUpdateField(category, uid) {
    //declare local variables
    var app = new Firebase(fbURL);
    var catRemovingFrom = app.child('Users').child(uid).child('events').child(category).child('updated'); //return the promise

    return $q(function (resolve, reject) {
      catRemovingFrom.set(null, function (error) {
        if (error) reject('There was an error deleting update field: ' + error);else resolve('Deleted update successfully');
      });
    });
  }

  function removeIncompleteEvent(uid, eventId) {
    //declare local variables
    var app = new Firebase(fbURL);
    var eventToRemove = app.child('Users').child(uid).child('events').child('hosting').child(eventId);
    return $q(function (resolve, reject) {
      var onComplete = function onComplete(error) {
        if (error) {
          reject('Synchronization failed');
        } else {
          resolve('Synchronization succeeded');
        }
      }; //call do db


      eventToRemove.remove(onComplete);
    });
  }

  function thereWasAnUpdateField(category, uid) {
    //declare local variables
    var app = new Firebase(fbURL);
    var catToCheck = app.child('Users').child(uid).child('events').child(category); //return the promise

    return $q(function (resolve, reject) {
      //call the db
      catToCheck.once('value', function (snapshot) {
        //save the response
        var currentCatModel = snapshot.val(); //show what was found
        //look for the update field

        if (angular.isDefined(currentCatModel['updated'])) resolve(true);else reject(false);
      }, function (error) {
        if (error) reject(error);
      });
    });
  } //return the object


  return allBackendServices;
}
"use strict";

angular.module('meetUpEventApp').factory('trafficValet', trafficValet);
trafficValet.$inject = ['$log', '$location'];
/* @ngInject */

function trafficValet($log, $location) {
  //declare local variables
  var allTrafficControls = {
    redirectTo: redirectTo,
    eventRoute: eventRoute
  };

  function redirectTo(path, param1, param2, param3) {
    if (angular.isDefined(param1)) {
      path = path + '/' + param1;

      if (angular.isDefined(param2)) {
        //go to path with 2 params
        path = path + '/' + param2;

        if (angular.isDefined(param3)) {
          path = path + '/' + param3;
          $location.path(path);
        }

        $location.path(path);
      } //go with 1 param


      $location.path(path);
    } else {
      //just go to path
      $location.path(path);
    }
  }

  function eventRoute(eventId, hostId, userId, section) {
    //if there isn't a section set to default
    if (angular.isUndefined(section)) section = 1; //if the hostId and userId match, launch host view

    if (hostId === userId) {
      var path = '/event/host/' + eventId + '/' + userId + '/' + section; //redirect

      $location.path(path);
    } //if the hostId and userId DON'T match, launch guest view
    else {
        var path = '/event/guest/' + eventId + '/' + userId + '/' + hostId; //redirect

        $location.path(path);
      }
  }

  return allTrafficControls;
}
"use strict";

angular.module('meetUpEventApp').factory('userData', userData);
userData.$inject = ['$log', '$q', 'backendServices'];
/* @ngInject */

function userData($log, $q, backendServices) {
  //declare local variables
  var currentUser = {
    bio: {
      uid: '',
      name: '',
      email: '',
      company: '',
      title: '',
      dob: 0
    },
    events: {
      hosting: {},
      pending: {},
      attending: {},
      completed: {}
    }
  };
  var activeEvent = {}; //local functions

  function utf8_to_b64(str) {
    return btoa(str);
  }

  function b64_to_utf8(str) {
    return atob(str);
  }

  function unixTimeToDateTime(unixTime) {
    return new Date(parseInt(unixTime));
  }

  ;

  function dateTimeToUnixTime(dateTime) {
    return Date.parse(dateTime);
  }

  ;
  var allUserData = {
    bioPrimariesAreCompleteLocally: bioPrimariesAreCompleteLocally,
    //modal analysis
    eventExistsLocally: eventExistsLocally,
    thisIsTheHostEmail: thisIsTheHostEmail,
    guestInvitedAlready: guestInvitedAlready,
    thereIsAnActiveEvent: thereIsAnActiveEvent,
    cleanEvents: cleanEvents,
    //model maintainance
    getUIDLocally: getUIDLocally,
    //getter Methods
    getNameLocally: getNameLocally,
    getEmailLocally: getEmailLocally,
    getCompanyLocally: getCompanyLocally,
    getTitleLocally: getTitleLocally,
    getDOBLocally: getDOBLocally,
    getFullBioLocally: getFullBioLocally,
    getOneUserEventLocally: getOneUserEventLocally,
    getUserEventsLocally: getUserEventsLocally,
    getAllUserEventsLocally: getAllUserEventsLocally,
    getActiveEvent: getActiveEvent,
    setUIDLocally: setUIDLocally,
    //setter Methods
    setNameLocally: setNameLocally,
    setEmailLocally: setEmailLocally,
    setCompanyLocally: setCompanyLocally,
    setTitleLocally: setTitleLocally,
    setDOBLocally: setDOBLocally,
    setPrimariesLocally: setPrimariesLocally,
    updateUserEventsLocally: updateUserEventsLocally,
    updateAllUserEventsLocally: updateAllUserEventsLocally,
    updateBioLocally: updateBioLocally,
    addGuestToHostGuestList: addGuestToHostGuestList,
    setActiveEvent: setActiveEvent,
    addGuestToActiveEvent: addGuestToActiveEvent,
    saveNewHostingEvent: saveNewHostingEvent,
    removeUserEventsLocally: removeUserEventsLocally,
    //remove data
    getFullRemoteDBforLocal: getFullRemoteDBforLocal,
    //local-remote interacions
    getRemoteBioForLocal: getRemoteBioForLocal,
    getRemoteEventsForLocal: getRemoteEventsForLocal,
    getOneRemoteEventForLocal: getOneRemoteEventForLocal,
    setFullRemoteDBfromLocal: setFullRemoteDBfromLocal,
    setRemoteBioFromLocal: setRemoteBioFromLocal,
    setARemoteEventFromLocal: setARemoteEventFromLocal,
    setRemoteEventsFromLocal: setRemoteEventsFromLocal,
    cleanDBEventsCategory: cleanDBEventsCategory,
    getUserIdForGuest: getUserIdForGuest,
    getEventGuestList: getEventGuestList,
    removeIncompleteEventFromDB: removeIncompleteEventFromDB,
    loadBio: loadBio,
    //external methods
    loadEventsProgressively: loadEventsProgressively,
    loadAnEventProgressively: loadAnEventProgressively,
    createNewEvent: createNewEvent,
    updatePendingEventsListForGuest: updatePendingEventsListForGuest
  }; //analysis methods

  function bioPrimariesAreCompleteLocally() {
    if (currentUser.bio.uid !== '' && currentUser.bio.name !== '' && currentUser.bio.email !== '') return true;else return false;
  }

  function eventExistsLocally(type, eventId) {
    if (angular.isDefined(currentUser.events[type][eventId])) return true;else return false;
  }

  function thisIsTheHostEmail(email, eventId) {
    //check if a bio is loaded
    if (angular.isDefined(currentUser.bio.email)) {
      if (currentUser.bio.email != '') {
        //check for a match
        if (email == currentUser.bio.email) {
          return true;
        } else {
          return false;
        }
      }
    } //if that didn't work check the current event


    if (currentUser.events.hosting[eventId].host.email == email) {
      return true;
    } else {
      return false;
    }
  }

  function guestInvitedAlready(email, eventId) {
    //first check if there is a guest list
    if (angular.isDefined(currentUser.events.hosting[eventId].guestList)) {
      //if there is a list, check for the email
      //convert email for evaluation
      refEmail = utf8_to_b64(email); //run through each guest and compare

      Object.keys(currentUser.events.hosting[eventId].guestList).forEach(function (b64Email) {
        if (refEmail == b64Email) {
          $log.info('an email match was found, this guest has been invited already');
          return true;
        } else {
          $log.info('no email match found, ok to invite guest');
          return false;
        }
      });
    } else {
      //if no guest list than can't already be on it
      $log.info('no guestlist');
      return false;
    }
  }

  function thereIsAnActiveEvent() {
    if (angular.isDefined(activeEvent.event)) {
      return true;
    } else return false;
  } //model maintainance


  function cleanEvents(type) {
    //iterate through objects in object
    Object.keys(currentUser.events[type]).forEach(function (key) {
      //if any are non-objects, delete them
      if (!angular.isObject(currentUser.events[type][key])) {
        delete currentUser.events[type][key];
      }
    });
  } //getter methods


  function getUIDLocally() {
    return currentUser.bio.uid;
  }

  function getNameLocally() {
    return currentUser.bio.name;
  }

  function getEmailLocally() {
    return currentUser.bio.email;
  }

  function getCompanyLocally() {
    return currentUser.bio.company;
  }

  function getTitleLocally() {
    return currentUser.bio.title;
  }

  function getDOBLocally() {
    return currentUser.bio.dob;
  }

  function getFullBioLocally() {
    return {
      uid: currentUser.bio.uid,
      name: currentUser.bio.name,
      email: currentUser.bio.email,
      company: currentUser.bio.company,
      title: currentUser.bio.title,
      dob: currentUser.bio.dob
    };
  }

  function getOneUserEventLocally(type, eventId) {
    return currentUser.events[type][eventId];
  }

  function getUserEventsLocally(type) {
    return currentUser.events[type];
  }

  function getAllUserEventsLocally() {
    return currentUser.events;
  }

  function getActiveEvent() {
    return activeEvent;
  } //setter methods


  function setUIDLocally(uid) {
    currentUser.bio.uid = uid;
  }

  function setNameLocally(name) {
    currentUser.bio.name = name;
  }

  function setEmailLocally(email) {
    currentUser.bio.email = email;
  }

  function setCompanyLocally(company) {
    currentUser.bio.company = company;
  }

  function setTitleLocally(title) {
    currentUser.bio.title = title;
  }

  function setDOBLocally(dob) {
    currentUser.bio.dob = dob;
  }

  function setPrimariesLocally(email, name, uid) {
    if (angular.isDefined(email)) setEmailLocally(email);
    if (angular.isDefined(name)) setNameLocally(name);
    if (angular.isDefined(uid)) setUIDLocally(uid);
  }

  function updateUserEventsLocally(type, event) {
    //declare local variables
    var eventID = event.id; //check if the model needs to be cleaned

    cleanEvents(type); //then load the new event

    currentUser.events[type][eventID] = event;
  }

  function updateAllUserEventsLocally(allUserEvents) {
    currentUser.events = allUserEvents;
  }

  function updateBioLocally(userBio) {
    //update local values
    setNameLocally(userBio.name);
    setEmailLocally(userBio.email);
    setCompanyLocally(userBio.company);
    setTitleLocally(userBio.title);
    setDOBLocally(userBio.dob); //save to db

    setRemoteBioFromLocal();
  }

  function addGuestToHostGuestList(name, email, guestId, eventId, uid) {
    //call to the db so return a promise
    var db = backendServices;
    return $q(function (resolve, reject) {
      //convert the email if one was passed
      if (angular.isDefined(email)) {
        guestId = utf8_to_b64(email);
      }

      db.addGuestToHostGuestListonDB(name, guestId, eventId, uid).then(function (positiveResult) {
        resolve(positiveResult);
      })["catch"](function (negativeResult) {
        reject(negativeResult);
      });
    });
  }

  function setActiveEvent(event) {
    //
    activeEvent = event;
  }

  function addGuestToActiveEvent(newGuest) {
    //local variables
    var uid = newGuest.uid; //if this is the first guest, create the list object

    if (!angular.isObject(activeEvent.event.guestList)) {
      activeEvent.event.guestList = {};
    } //add the guest to the list


    activeEvent.event.guestList[uid] = newGuest.guest;
  }

  function getUserIdForGuest(email) {
    //call to the db so return a promise
    var db = backendServices;
    return $q(function (resolve, reject) {
      //convert the email
      guestEmail = utf8_to_b64(email);
      db.findGuestUID(guestEmail).then(function (uid) {
        resolve(uid);
      })["catch"](function (errorResponse) {
        reject(errorResponse);
      });
    });
  } //delete Methods


  function removeUserEventsLocally(type, event) {
    //does this work?
    delete currentUser.events[type][event.id];
  } //remote-local interaction Methods


  function getFullRemoteDBforLocal() {
    //local variables
    var db = backendServices;
    db.downloadUserData().then(function (remoteUserData) {
      currentUser = remoteUserData;
    });
  }

  function getRemoteBioForLocal(uid) {
    //local variables
    var db = backendServices;
    return $q(function (resolve, reject) {
      //go out to the db before resolving
      db.getUserBio(uid).then(function (userBio) {
        resolve(userBio);
      })["catch"](function (error) {
        reject('There was an error reading the user bio: ' + error);
      });
    });
  }

  function getRemoteEventsForLocal() {
    //local variables
    var db = backendServices;
    return $q(function (resolve, reject) {
      //go out to the db before resolving
      db.getUserEvents(getUIDLocally()).then(function (obtainedUserEvents) {
        //save the results to the local databse
        Object.keys(obtainedUserEvents).forEach(function (eventType) {
          //within each event type iterate through the actual events
          Object.keys(obtainedUserEvents[eventType]).forEach(function (event) {
            //once we see the events, save them to the local model
            updateUserEventsLocally(eventType, obtainedUserEvents[eventType][event]);
          });
        }); //return the results to the requesting object

        resolve(obtainedUserEvents);
      })["catch"](function (error) {
        reject('There was an error reading the user events: ' + error);
      });
    });
  }

  function getOneRemoteEventForLocal(eventId) {
    //local variables
    var db = backendServices;
    return $q(function (resolve, reject) {
      //going to backend services
      db.getAHostedEvent(getUIDLocally(), eventId).then(function (obtainedEvent) {
        //save the result to the local model
        //return the result to the requesting object
        resolve(obtainedEvent);
      })["catch"](function (error) {
        reject('There was an error reading the user event: ' + error);
      });
    });
  }

  function setFullRemoteDBfromLocal() {
    //local variables
    var db = backendServices;
    db.uploadUserData(currentUser);
  }

  function setRemoteBioFromLocal() {
    //local variables
    var db = backendServices;
    db.uploadUserBio(currentUser.bio);
  }

  function setARemoteEventFromLocal() {}

  function setRemoteEventsFromLocal(uid, event) {
    //declar local variables
    var db = backendServices;
    $log.info('sending this to the server');
    $log.info(event);
    return $q(function (resolve, reject) {
      //send the event to the db
      db.createHostedEvent(uid, event).then(function (successMessage) {
        resolve(successMessage);
      })["catch"](function (errorMessage) {
        reject(errorMessage);
      });
    });
  }

  function cleanDBEventsCategory(category) {
    //declar local variables
    var db = backendServices; //remove 'updated' object if need be
    //db call so return a promise

    return $q(function (resolve, reject) {
      //check for object
      db.thereWasAnUpdateField(category, getUIDLocally()).then(function (affirmativeResponse) {
        //if there was an update field, delete it
        db.deleteUpdateField(category, getUIDLocally()).then(function (affirmativeResponse) {
          $log.info(affirmativeResponse);
        })["catch"](function (errorResponse) {
          $log.info(errorResponse);
        });
      })["catch"](function (errorResponse) {
        $log.info(errorResponse);
      });
    }); //if it is there, remove it
  }

  function getEventGuestList(hostId, eventId) {
    //declare local variables
    var db = backendServices;
    return $q(function (resolve, reject) {
      //get the object
      db.getGuestListForEvent(hostId, eventId).then(function (obtainedList) {
        resolve(obtainedList);
      })["catch"](function (errorResponse) {
        reject(errorResponse);
      });
    });
  }

  function removeIncompleteEventFromDB(eventId) {
    //declare local variables
    var db = backendServices;
    return $q(function (resolve, reject) {
      db.removeIncompleteEvent(currentUser.getUIDLocally, eventId).then(function (successMessage) {
        resolve(successMessage);
      })["catch"](function (errorMessage) {
        reject(errorMessage);
      });
    });
  }

  function loadBio(uid) {
    //might need to go out to the db so return a promise
    return $q(function (resolve, reject) {
      //check for bio locally first
      if (bioPrimariesAreCompleteLocally()) {
        //pass it back as success
        resolve(getFullBioLocally());
      } else {
        //if they're not complete locally, check the server
        getRemoteBioForLocal(uid).then(function (bioFromRemoteDB) {
          //save them locally first
          setPrimariesLocally(bioFromRemoteDB.email, bioFromRemoteDB.name, bioFromRemoteDB.uid); //return the findings

          resolve(bioFromRemoteDB);
        })["catch"](function (error) {
          reject(error);
        });
      }
    });
  }

  function loadAnEventProgressively(uid, eventId) {
    //update uid if need be
    setUIDLocally(uid); //going out the the db so return a promise

    return $q(function (resolve, reject) {
      //reach out to db
      getOneRemoteEventForLocal(eventId).then(function (obtainedUserEvent) {
        //when the db results come back, return it
        resolve(obtainedUserEvent);
      })["catch"](); //first return whatever event info is stored locally
      //check if the event is available locally

      if (eventExistsLocally('hosting', eventId)) resolve(getOneUserEventLocally('hosting', eventId));
    });
  }

  function loadEventsProgressively(uid) {
    var eventTypes = ['attending', 'pending', 'hosting', 'completed'];
    var allEvents = {}; //will go out to the db so return a promise

    return $q(function (resolve, reject) {
      getRemoteEventsForLocal().then(function (obtainedUserEvents) {
        //when the db results come back, return those
        resolve(obtainedUserEvents);
      }); //build the local model

      allEvents = getUserEventsLocally(type); //first return whatever event info is stored locally

      resolve(allEvents);
    });
  }

  function createNewEvent(eventID) {
    //declar local variables
    var db = backendServices;
    var newEvent = {};
    var dateTime = new Date();
    dateTime.setMinutes(0, 0, 0);
    var tempTime = dateTimeToUnixTime(dateTime); //first create the object

    newEvent = {
      id: eventID,
      name: '',
      type: '',
      host: {
        name: currentUser.bio.name,
        uid: currentUser.bio.uid,
        email: currentUser.bio.email
      },
      message: '',
      eventTimes: {
        start: tempTime,
        end: tempTime + 60 * 60 * 1000
      },
      address: {
        street01: '',
        street02: '',
        street03: '',
        city: '',
        state: '',
        zip: 0
      }
    }; //save it locally

    updateUserEventsLocally('hosting', newEvent); //save it as the active event

    setActiveEvent(newEvent); //then create it on the server
    //will go out to the db so return a promise

    /*return $q(function(resolve, reject) {
    	
    	$log.info('saved locally, not on the db');
    	//manage the promise responses
    	/*db.createHostedEvent(getUIDLocally(), newEvent)
    	.then(function(message) {
    		resolve(message);
    	})
    	.catch(function(error) {
    		reject(error);
    	})
    	});*/
  }

  function updatePendingEventsListForGuest(eventId) {
    //declar local variables
    var db = backendServices;
    return $q(function (resolve, reject) {//manage the db promise
      //db.addPendingEventForGuest(currentUser.getUIDLocally(), hostId, eventId, currentUser.getUserEventsLocally('', eventId))
    });
  }

  function saveNewHostingEvent(category, event) {
    $log.info('saving this event locally');
    $log.info(event);
    updateUserEventsLocally(category, event);
  }

  return allUserData;
}
"use strict";

angular.module('meetUpEventApp').factory('validation', validation);
validation.$inject = ['$log'];
/* @ngInject */

function validation($log) {
  //declare local variables
  var minimumNameLength = 3;
  var minimumPassLength = 6;
  var maximumPassLength = 100; //validation objects

  var required = {
    met: false,
    errorMessage: 'This field is required',
    test: function test(value) {
      //throw the tested flag
      if (angular.isUndefined(value)) {
        return false;
      } else if (value == '') {
        this.tested = true;
        return false;
      } else {
        this.tested = true;
        return true;
      }
    }
  };
  var nameMinLength = {
    met: false,
    errorMessage: 'Too short (3 chars minimum)',
    test: function test(value) {
      //throw the tested flag
      if (angular.isDefined(value)) {
        this.tested = true;

        if (value.length >= 3) {
          return true;
        } else return false;
      }
    }
  };
  var isAnEmail = {
    met: false,
    errorMessage: 'This is not a valid email',
    test: function test(value) {
      //define regex
      var EMAIL_REGEXP = /[a-z0-9!#$%&'*+=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/g;
      var constraint = new RegExp(EMAIL_REGEXP);

      if (angular.isDefined(value)) {
        var constraintTest = constraint.test(value); //if email is defined

        if (constraintTest) {
          //if(constraint.test(value)) {
          //if it passes regex
          $log.info('it passed the test');
          return true;
        } else return false;
      } else return false;
    }
  };
  var passMinLength = {
    met: false,
    errorMessage: 'Should be at least 6 characters long',
    test: function test(value) {
      //throw the tested flag
      this.tested = true;

      if (angular.isDefined(value)) {
        if (value.length >= 6) {
          return true;
        } else return false;
      } else return false;
    }
  };
  var passMaxLength = {
    met: false,
    errorMessage: 'Should be no more than 100 characters',
    test: function test(value) {
      //throw the tested flag
      this.tested = true;

      if (angular.isDefined(value)) {
        if (value.length <= 100) {
          return true;
        } else return false;
      } else return false;
    }
  };
  var hasLowercase = {
    met: false,
    errorMessage: 'Should have at least one lowercase letter',
    test: function test(value) {
      //define regex
      var constraint = new RegExp("[a-z]");

      if (angular.isDefined(value)) {
        //if pass is defined
        if (constraint.test(value)) {
          //succes
          return true;
        } else return false;
      } else return false;
    }
  };
  var hasUppercase = {
    met: false,
    errorMessage: 'Should have at least one uppercase letter',
    test: function test(value) {
      //define regex
      var constraint = new RegExp("[A-Z]");

      if (angular.isDefined(value)) {
        //if pass is defined
        if (constraint.test(value)) {
          //succes
          return true;
        } else return false;
      } else return false;
    }
  };
  var hasANumber = {
    met: false,
    errorMessage: 'Should have at least one number letter',
    test: function test(value) {
      //define regex
      var constraint = new RegExp("[0-9]");

      if (angular.isDefined(value)) {
        //if pass is defined
        if (constraint.test(value)) {
          //succes
          return true;
        } else return false;
      } else return false;
    }
  };
  var hasASymbol = {
    met: false,
    errorMessage: 'Should have at least one symbol letter',
    test: function test(value) {
      //define regex
      var constraint = new RegExp("[\!\@\#\$\%\^\&\*]");

      if (angular.isDefined(value)) {
        //if pass is defined
        if (constraint.test(value)) {
          //succes
          return true;
        } else return false;
      } else return false;
    }
  };
  var noIllegalChars = {
    met: false,
    errorMessage: 'Should be at least 6 characters long',
    test: function test(value) {
      var constraint = new RegExp("[^A-z0-9\!\@\#\$\%\^\&\*]");

      if (angular.isDefined(value)) {
        //if pass is defined
        if (constraint.test(value)) {
          //succes
          return false;
        } else return true;
      } else return true;
    }
  };
  var allValidations = {
    required: required,
    //new User validations
    minNameLength: minNameLength,
    minPassLength: minPassLength,
    maxPassLength: maxPassLength,
    atLeastOneSymbol: atLeastOneSymbol,
    atLeastOneNumber: atLeastOneNumber,
    atLeastOneLowercase: atLeastOneLowercase,
    atLeastOneUppercase: atLeastOneUppercase,
    illegalCharacter: illegalCharacter,
    email: email,
    dateOfBirth: dateOfBirth,
    generateEventRequirnments: generateEventRequirnments,
    //event requirnments
    generateNewUserRequirnemnts: generateNewUserRequirnemnts,
    updateEventReqStatus: updateEventReqStatus,
    updateEventReqAddressed: updateEventReqAddressed,
    updateEventReqClass: updateEventReqClass,
    generateTestableObject: generateTestableObject
  };

  function required(value) {
    if (angular.isUndefined(value)) {
      return 'This is a required field';
    }
  }

  function minNameLength(value) {
    if (angular.isDefined(value)) {
      if (value.length < minimumNameLength) return 'Name should be at least ' + minimumNameLength + ' characters';
    }
  }

  function minPassLength(value) {
    if (angular.isDefined(value)) {
      if (!(value.length < minimumPassLength)) return true;
    }

    return false;
  }

  function maxPassLength(value) {
    if (angular.isDefined(value)) {
      if (!(value.length > maximumPassLength)) return true;
    }

    return false;
  }

  function atLeastOneSymbol(value) {
    if (angular.isDefined(value)) {
      // build regex
      var constraint = new RegExp("[\!\@\#\$\%\^\&\*]"); //check constratint

      if (constraint.test(value)) {
        //success: at least one special character found
        return true;
      } else {
        //failure: didn't find any spcial characters
        return false;
      }
    }

    return false;
  }

  function atLeastOneNumber(value) {
    if (angular.isDefined(value)) {
      // build regex
      var constraint = new RegExp("[0-9]", ""); //check constratint

      if (constraint.test(value)) {
        //success: at least one special character found
        return true;
      } else {
        //failure: didn't find any spcial characters
        return false;
      }
    }

    return false;
  }

  function atLeastOneLowercase(value) {
    if (angular.isDefined(value)) {
      // build regex
      var constraint = new RegExp("[a-z]", ""); //check constratint

      if (constraint.test(value)) {
        //success: at least one special character found
        return true;
      } else {
        //failure: didn't find any spcial characters
        return false;
      }
    }

    return false;
  }

  function atLeastOneUppercase(value) {
    if (angular.isDefined(value)) {
      // build regex
      var constraint = new RegExp("[A-Z]", ""); //check constratint

      if (constraint.test(value)) {
        //success: at least one special character found
        return true;
      } else {
        //failure: didn't find any spcial characters
        return false;
      }
    }

    return false;
  }

  function illegalCharacter(value) {
    if (angular.isDefined(value)) {
      // build regex
      var constraint = new RegExp("[^A-z0-9\!\@\#\$\%\^\&\*]", ""); //check constratint

      if (constraint.test(value)) {
        //success: at least one special character found
        return false;
      } else {
        //failure: didn't find any spcial characters
        return true;
      }
    }

    return false;
  }

  function email(value) {
    //define constraints
    var EMAIL_REGEXP = /[a-z0-9!#$%&'*+=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/g;
    var constraint = new RegExp(EMAIL_REGEXP);
    if (angular.isDefined(value) && !constraint.test(value)) return 'Not a valid email';
  }

  function dateOfBirth(value) {}

  function generateNewUserRequirnemnts() {
    //declare the object
    var errorsObject = {
      name: {
        name: {
          status: false,
          message: 'A name is required'
        },
        validLength: {
          status: false,
          message: 'Name must be at least 3 characters long'
        }
      },
      email: {
        email: {
          status: false,
          message: 'An email is required'
        },
        validEmail: {
          status: false,
          message: 'This is not a valid email'
        }
      },
      pass: {
        pass: {
          status: false,
          message: 'A password is required'
        },
        tooShort: {
          status: false,
          message: 'There should be at least 6 characters'
        },
        tooLong: {
          status: false,
          message: 'There should be no more than 100 characters'
        },
        noLowercase: {
          status: false,
          message: 'There should be at least one lowercase letter'
        },
        noUppercase: {
          status: false,
          message: 'There should be at least one uppercase letter'
        },
        noNumber: {
          status: false,
          message: 'There should be at least one number'
        },
        noSymbol: {
          status: false,
          message: 'There should be at least one symbol'
        },
        hasInvalidChar: {
          status: false,
          message: 'There shouldn\'t be any invalid characters'
        }
      },
      changeStatus: function changeStatus(input, req, status) {
        this[input][req].status = status;
      },
      getErrorMessage: function getErrorMessage(input, req) {
        return this[input][req].message;
      },
      allReqsFulfilled: function allReqsFulfilled(input) {
        Object.keys(input).forEach(function (req) {
          if (!input[req].status) return false;
        });
      },
      allInputsPass: function allInputsPass() {
        Object.keys(this).forEach(function (input) {
          if (!this.allReqsFulfilled(input)) return false;
        });
      },
      getAllErrors: function getAllErrors() {
        var allErrors = {};
        Object.keys(this).forEach(function (input) {
          //if the value is an object
          if (angular.isObject(this[input])) {
            Object.keys(input).forEach(function (req) {
              if (this[input][req].status) {
                allErrors[input] = {};
                allErrors[input][req] = {
                  message: this[input][req].message
                };
              }
            });
          }
        });
        return allErrors;
      }
    };
    return errorsObject;
  }

  function generateEventRequirnments() {
    //build the object and return it
    var eventValidations = {
      eventName: {
        completed: false,
        addressed: false,
        row: {
          "class": {
            'col-xs-12': true,
            'col-sm-12': true,
            'form-group': true,
            'has-success': false,
            'has-error': false
          }
        },
        label: {
          "class": {
            'control-label': true
          }
        },
        input: {
          "class": {
            'form-control': true,
            'col-xs-12': true,
            'col-sm-12': true,
            'col-md-12': true
          }
        }
      },
      eventHost: {
        completed: false,
        addressed: false,
        row: {
          "class": {
            'col-xs-12': true,
            'col-sm-12': true,
            'form-group': true,
            'has-success': false,
            'has-error': false
          }
        },
        label: {
          "class": {
            'control-label': true
          }
        },
        input: {
          "class": {
            'form-control': true
          }
        }
      },
      eventType: {
        completed: false,
        addressed: false,
        row: {
          "class": {
            'col-xs-12': true,
            'col-sm-12': true,
            'form-group': true,
            'has-success': false,
            'has-error': false
          }
        },
        label: {
          "class": {
            'control-label': true
          }
        },
        input: {
          "class": {
            'form-control': true
          }
        }
      },
      eventStart: {
        completed: false,
        addressed: false,
        row: {
          "class": {
            'col-xs-12': true,
            'col-sm-12': true,
            'form-group': true,
            'has-success': false,
            'has-error': false
          }
        },
        label: {
          "class": {
            'control-label': true
          }
        },
        input: {
          "class": {
            'form-control': true
          }
        }
      },
      eventEnd: {
        completed: false,
        addressed: false,
        row: {
          "class": {
            'col-xs-12': true,
            'col-sm-12': true,
            'form-group': true,
            'has-success': false,
            'has-error': false
          }
        },
        label: {
          "class": {
            'control-label': true
          }
        },
        input: {
          "class": {
            'form-control': true
          }
        }
      },
      eventStreet01: {
        completed: false,
        addressed: false,
        row: {
          "class": {
            'col-xs-12': true,
            'col-sm-12': true,
            'form-group': true,
            'has-success': false,
            'has-error': false
          }
        },
        label: {
          "class": {
            'control-label': true
          }
        },
        input: {
          "class": {
            'form-control': true
          }
        }
      },
      eventCity: {
        completed: false,
        addressed: false,
        row: {
          "class": {
            'col-xs-12': true,
            'col-sm-12': true,
            'form-group': true,
            'has-success': false,
            'has-error': false
          }
        },
        label: {
          "class": {
            'control-label': true
          }
        },
        input: {
          "class": {
            'form-control': true
          }
        }
      },
      eventState: {
        completed: false,
        addressed: false,
        row: {
          "class": {
            'col-xs-12': true,
            'col-sm-12': true,
            'form-group': true,
            'has-success': false,
            'has-error': false
          }
        },
        label: {
          "class": {
            'control-label': true
          }
        },
        input: {
          "class": {
            'form-control': true
          }
        }
      },
      eventZip: {
        completed: false,
        addressed: false,
        row: {
          "class": {
            'col-xs-12': true,
            'col-sm-12': true,
            'form-group': true,
            'has-success': false,
            'has-error': false
          }
        },
        label: {
          "class": {
            'control-label': true
          }
        },
        input: {
          "class": {
            'form-control': true
          }
        }
      },
      eventGuest: {
        completed: false,
        addressed: false,
        row: {
          "class": {
            'col-xs-12': true,
            'col-sm-12': true,
            'form-group': true,
            'has-success': false,
            'has-error': false
          }
        },
        label: {
          "class": {
            'control-label': true
          }
        },
        input: {
          "class": {
            'form-control': true
          }
        }
      }
    };
    return eventValidations;
  }

  function updateClasses() {
    //check the validity state
    if (this.passesAllReqs) {
      this["class"].row['has-success'] = true;
      this["class"].row['has-error'] = false;
      this.style['background-color'] = '#78FA89';
      this.style['color'] = 'black';
    } else {
      this["class"].row['has-success'] = false;
      this["class"].row['has-error'] = true;
      this.style['background-color'] = '#FA787E';
      this.style['color'] = 'white';
    }
  }

  function updateReqStyles() {
    //local variables
    var requirnments = this.reqs;
    var reqBox = this.reqBox; //iterate through each req

    Object.keys(requirnments).forEach(function (key) {
      if (requirnments[key].met) {
        reqBox[key].style.color = 'green';
      } else {
        reqBox[key].style.color = 'red';
      }
    });
  }

  function buildErrorMessage() {
    //declare local variables
    var requirnments = this.reqs;
    var objectErrors = []; //check for failed tests

    Object.keys(requirnments).forEach(function (test) {
      //if the test isn't met add the error message to the array of messages
      if (!requirnments[test].met) objectErrors.push(requirnments[test].errorMessage);
    }); //assemble message

    this.errorMessage = objectErrors.join(', ');
  }

  function checkForValue() {
    if (angular.isDefined(this.value) && this.value != '') this.hasValue = true;else this.hasValue = false;
  }

  function checkForErrorMessage() {
    //only unlock error message if tests have been run at least once
    if (this.allReqsTested) {
      //check
      if (angular.isDefined(this.errorMessage) && this.errorMessage != '') this.hasAnErrorMessage = true;else this.hasAnErrorMessage = false;
    }
  }

  function checkAllRequirnments() {
    //declare local variables
    var requirnments = this.reqs;
    var value = this.value;
    var allTestsPass = true; //run through requirnments

    Object.keys(requirnments).forEach(function (test) {
      //pass the value and test the constraint
      if (requirnments[test].test(value)) {
        //if it passes the test update the status
        requirnments[test].met = true; //get the error message
        //allTestsPass = true
      } else {
        requirnments[test].met = false;
        allTestsPass = false;
      }
    }); //update the flag

    this.passesAllReqs = allTestsPass;

    if (!allTestsPass) {
      //build the error message
      this.buildErrorMessage(); //throw it's flag

      this.hasAnErrorMessage = true;
    } else {
      this.hasAnErrorMessage = false;
    } //update element classes


    this.updateClasses(); //update styles if need be

    if (angular.isDefined(this.updateReqStyles)) this.updateReqStyles(); //throw allReqsTested flag

    this.allReqsTested = true;
  }

  function postFailReqsTest() {
    //if a complete attempt has occured then check on keystroke
    if (this.allReqsTested) {
      this.checkAllRequirnments();
    }
  }

  function openReqBox() {
    this.showReqsBox = true;
  }

  function closeReqBox() {
    this.showReqsBox = false;
  }

  function generateTestableObject(type) {
    //build objects
    var testableObjects = {
      name: {
        value: '',
        reqs: {
          hasOne: required,
          longEnough: nameMinLength
        },
        errorMessage: '',
        hasValue: false,
        passesAllReqs: false,
        allReqsTested: false,
        hasAnErrorMessage: false,
        buildErrorMessage: buildErrorMessage,
        checkForValue: checkForValue,
        checkForErrorMessage: checkForErrorMessage,
        checkAllRequirnments: checkAllRequirnments,
        postFailReqsTest: postFailReqsTest,
        updateClasses: updateClasses,
        "class": {
          row: {
            'col-xs-12': true,
            'col-sm-12': true,
            'form-group': true,
            'has-success': false,
            'has-error': false
          },
          label: {
            'control-label': true
          },
          input: {
            'col-xs-12': true,
            'col-sm-12': true,
            'col-md-12': true,
            'form-control': true
          }
        },
        style: {
          'color': 'black'
        }
      },
      email: {
        value: '',
        reqs: {
          hasOne: required,
          isAnEmail: isAnEmail
        },
        errorMessage: '',
        hasValue: false,
        passesAllReqs: false,
        allReqsTested: false,
        hasAnErrorMessage: false,
        buildErrorMessage: buildErrorMessage,
        checkForValue: checkForValue,
        checkForErrorMessage: checkForErrorMessage,
        checkAllRequirnments: checkAllRequirnments,
        postFailReqsTest: postFailReqsTest,
        updateClasses: updateClasses,
        "class": {
          row: {
            'col-xs-12': true,
            'col-sm-12': true,
            'form-group': true,
            'has-success': false,
            'has-error': false
          },
          label: {
            'control-label': true
          },
          input: {
            'col-xs-12': true,
            'col-sm-12': true,
            'col-md-12': true,
            'form-control': true
          }
        },
        style: {
          'color': 'black'
        }
      },
      pass: {
        value: '',
        reqs: {
          hasOne: required,
          longEnough: passMinLength,
          shortEnough: passMaxLength,
          hasLowercase: hasLowercase,
          hasUppercase: hasUppercase,
          hasANumber: hasANumber,
          hasASymbol: hasASymbol,
          noIllegalChars: noIllegalChars
        },
        errorMessage: '',
        hasValue: false,
        passesAllReqs: false,
        allReqsTested: false,
        hasAnErrorMessage: false,
        showReqsBox: false,
        buildErrorMessage: buildErrorMessage,
        checkForValue: checkForValue,
        checkForErrorMessage: checkForErrorMessage,
        checkAllRequirnments: checkAllRequirnments,
        postFailReqsTest: postFailReqsTest,
        updateClasses: updateClasses,
        updateReqStyles: updateReqStyles,
        openReqBox: openReqBox,
        closeReqBox: closeReqBox,
        "class": {
          row: {
            'col-xs-12': true,
            'col-sm-12': true,
            'form-group': true,
            'has-success': false,
            'has-error': false
          },
          label: {
            'control-label': true
          },
          input: {
            'col-xs-12': true,
            'col-sm-12': true,
            'col-md-12': true,
            'form-control': true
          }
        },
        style: {
          'color': 'black'
        },
        reqBox: {
          hasOne: {
            req: 'Need to set a password',
            'style': {
              color: 'red'
            }
          },
          longEnough: {
            req: 'Is at least 6 characters long',
            'style': {
              color: 'red'
            }
          },
          shortEnough: {
            req: 'Is no longer than 100 characters',
            'style': {
              color: 'red'
            }
          },
          hasLowercase: {
            req: 'Contains at least one lowercase letter',
            'style': {
              color: 'red'
            }
          },
          hasUppercase: {
            req: 'Contains at least one uppercase letter',
            'style': {
              color: 'red'
            }
          },
          hasANumber: {
            req: 'Contains at least one number',
            'style': {
              color: 'red'
            }
          },
          hasASymbol: {
            req: 'Contains at least one required symbol (\!\@\#\$\%\^\&\*)',
            'style': {
              color: 'red'
            }
          },
          noIllegalChars: {
            req: 'Doesn\'t have any illegal characters',
            'style': {
              color: 'red'
            }
          }
        }
      }
    };
    return testableObjects[type];
  }

  function updateEventReqStatus() {}

  function updateEventReqAddressed() {}

  function updateEventReqClass() {}

  return allValidations;
}
"use strict";

config.$inject = ["$routeProvider"];
userAuthenticationService.$inject = ["authService"];
eventViewChanger.$inject = ["trafficValet", "$route"];
angular.module('meetUpEventApp').config(config);
/* @ngInject */

function config($routeProvider) {
  $routeProvider.when('/', {
    templateUrl: 'views/landingPage.htm',
    controller: 'LandingPageController',
    controllerAs: 'vm'
  }).when('/signup', {
    templateUrl: 'views/newUserSignup.htm',
    controller: 'NewUserSignUpController',
    controllerAs: 'vm'
  }).when('/login', {
    templateUrl: 'views/registeredUserLogin.htm',
    controller: 'RegUserLoginController',
    controllerAs: 'vm'
  }).when('/userInformation/:uid?', {
    templateUrl: 'views/userInformation.htm',
    controller: 'UserInformationController',
    controllerAs: 'vm',
    resolve: {
      /* @ngInject */
      userAuthenticationService: userAuthenticationService
    }
  }).when('/userEvents/:uid?', {
    templateUrl: 'views/userEvents.htm',
    controller: 'UserEventsController',
    controllerAs: 'vm',
    resolve: {
      /* @ngInject */
      userAuthenticationService: userAuthenticationService
    }
  }).when('/event/host/:eventId/:uid/:section', {
    templateUrl: 'views/hostEvent.htm',
    controller: 'HostEventController',
    controllerAs: 'vm',
    resolve: {
      /* @ngInject */
      userAuthenticationService: userAuthenticationService
    }
  }).when('/event/guest/:eventId/:uid/:hostId', {
    templateUrl: 'views/guestEvent.htm',
    controller: 'GuestEventController',
    controllerAs: 'vm',
    resolve: {
      /* @ngInject */
      userAuthenticationService: userAuthenticationService
    }
  }).when('/event/:eventId?/:hostId?/:uid?/:section?', {
    templateUrl: 'views/anEvent.htm',
    controller: 'AnEventController',
    controllerAs: 'vm',
    resolve: {
      /* @ngInject */
      userAuthenticationService: userAuthenticationService,
      eventViewChanger: eventViewChanger
    }
  }).otherwise({
    redirectTo: '/'
  });
}

function userAuthenticationService(authService) {
  authService.isLoggedIn();
}

;

function eventViewChanger(trafficValet, $route) {
  trafficValet.eventRoute($route.current.params.eventId, $route.current.params.hostId, $route.current.params.uid, $route.current.params.section);
}

;